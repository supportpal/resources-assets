!function (e) {
  "function" == typeof define && define.amd ? define(e) : e();
}(function () {
  "use strict";

  /*! shepherd.js 13.0.3 */
  function e(e) {
    return e instanceof HTMLElement;
  }
  function t(e) {
    return "function" == typeof e;
  }
  function n(e) {
    return "string" == typeof e;
  }
  function o(e) {
    return void 0 === e;
  }
  class r {
    on(e, t, n, r = !1) {
      var i;
      return o(this.bindings) && (this.bindings = {}), o(this.bindings[e]) && (this.bindings[e] = []), null == (i = this.bindings[e]) || i.push({
        handler: t,
        ctx: n,
        once: r
      }), this;
    }
    once(e, t, n) {
      return this.on(e, t, n, !0);
    }
    off(e, t) {
      if (o(this.bindings) || o(this.bindings[e])) return this;
      var n;
      o(t) ? delete this.bindings[e] : null == (n = this.bindings[e]) || n.forEach((n, o) => {
        var r;
        n.handler === t && (null == (r = this.bindings[e]) || r.splice(o, 1));
      });
      return this;
    }
    trigger(e, ...t) {
      var n;
      !o(this.bindings) && this.bindings[e] && (null == (n = this.bindings[e]) || n.forEach((n, o) => {
        const {
            ctx: r,
            handler: i,
            once: s
          } = n,
          l = r || this;
        var a;
        (i.apply(l, t), s) && (null == (a = this.bindings[e]) || a.splice(o, 1));
      }));
      return this;
    }
  }
  function i() {
    return i = Object.assign ? Object.assign.bind() : function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var o in n) ({}).hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    }, i.apply(null, arguments);
  }
  function s(e, t) {
    if (null == e) return {};
    var n = {};
    for (var o in e) if ({}.hasOwnProperty.call(e, o)) {
      if (t.includes(o)) continue;
      n[o] = e[o];
    }
    return n;
  }
  const l = {
    defaultMerge: Symbol("deepmerge-ts: default merge"),
    skip: Symbol("deepmerge-ts: skip")
  };
  function a(e, t) {
    return t;
  }
  function c(e) {
    return "object" != typeof e || null === e ? 0 : Array.isArray(e) ? 2 : function (e) {
      if (!h.has(Object.prototype.toString.call(e))) return !1;
      const {
        constructor: t
      } = e;
      if (void 0 === t) return !0;
      const n = t.prototype;
      if (null === n || "object" != typeof n || !h.has(Object.prototype.toString.call(n))) return !1;
      if (!n.hasOwnProperty("isPrototypeOf")) return !1;
      return !0;
    }(e) ? 1 : e instanceof Set ? 3 : e instanceof Map ? 4 : 5;
  }
  function d(e) {
    return {
      *[Symbol.iterator]() {
        for (const t of e) for (const e of t) yield e;
      }
    };
  }
  l.defaultMerge;
  const h = new Set(["[object Object]", "[object Module]"]);
  function u(e) {
    return e.at(-1);
  }
  var p = Object.freeze({
    __proto__: null,
    mergeArrays: function (e) {
      return e.flat();
    },
    mergeMaps: function (e) {
      return new Map(d(e));
    },
    mergeOthers: u,
    mergeRecords: function (e, t, n) {
      const o = {};
      for (const s of function (e) {
        const t = new Set();
        for (const n of e) for (const e of [...Object.keys(n), ...Object.getOwnPropertySymbols(n)]) t.add(e);
        return t;
      }(e)) {
        const a = [];
        for (const t of e) i = s, "object" == typeof (r = t) && Object.prototype.propertyIsEnumerable.call(r, i) && a.push(t[s]);
        if (0 === a.length) continue;
        const c = t.metaDataUpdater(n, {
            key: s,
            parents: e
          }),
          d = g(a, t, c);
        d !== l.skip && ("__proto__" === s ? Object.defineProperty(o, s, {
          value: d,
          configurable: !0,
          enumerable: !0,
          writable: !0
        }) : o[s] = d);
      }
      var r, i;
      return o;
    },
    mergeSets: function (e) {
      return new Set(d(e));
    }
  });
  function f(...e) {
    return function (e, t) {
      const n = function (e, t) {
        var n, o;
        return {
          defaultMergeFunctions: p,
          mergeFunctions: i({}, p, Object.fromEntries(Object.entries(e).filter(([e, t]) => Object.hasOwn(p, e)).map(([e, t]) => !1 === t ? [e, u] : [e, t]))),
          metaDataUpdater: null != (n = e.metaDataUpdater) ? n : a,
          deepmerge: t,
          useImplicitDefaultMerging: null != (o = e.enableImplicitDefaultMerging) && o,
          actions: l
        };
      }(e, o);
      function o(...e) {
        return g(e, n, t);
      }
      return o;
    }({})(...e);
  }
  function g(e, t, n) {
    if (0 === e.length) return;
    if (1 === e.length) return m(e, t, n);
    const o = c(e[0]);
    if (0 !== o && 5 !== o) for (let r = 1; r < e.length; r++) if (c(e[r]) !== o) return m(e, t, n);
    switch (o) {
      case 1:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeRecords(e, t, n);
          if (o === l.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeRecords !== t.defaultMergeFunctions.mergeRecords) return t.defaultMergeFunctions.mergeRecords(e, t, n);
          return o;
        }(e, t, n);
      case 2:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeArrays(e, t, n);
          if (o === l.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeArrays !== t.defaultMergeFunctions.mergeArrays) return t.defaultMergeFunctions.mergeArrays(e);
          return o;
        }(e, t, n);
      case 3:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeSets(e, t, n);
          if (o === l.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeSets !== t.defaultMergeFunctions.mergeSets) return t.defaultMergeFunctions.mergeSets(e);
          return o;
        }(e, t, n);
      case 4:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeMaps(e, t, n);
          if (o === l.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeMaps !== t.defaultMergeFunctions.mergeMaps) return t.defaultMergeFunctions.mergeMaps(e);
          return o;
        }(e, t, n);
      default:
        return m(e, t, n);
    }
  }
  function m(e, t, n) {
    const o = t.mergeFunctions.mergeOthers(e, t, n);
    return o === l.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeOthers !== t.defaultMergeFunctions.mergeOthers ? t.defaultMergeFunctions.mergeOthers(e) : o;
  }
  function b(e) {
    const t = Object.getOwnPropertyNames(e.constructor.prototype);
    for (let n = 0; n < t.length; n++) {
      const o = t[n],
        r = e[o];
      "constructor" !== o && "function" == typeof r && (e[o] = r.bind(e));
    }
    return e;
  }
  function x(e) {
    const {
      event: t,
      selector: n
    } = e.options.advanceOn || {};
    if (!t) return void 0;
    {
      const r = function (e, t) {
        return n => {
          if (e.isOpen()) {
            const r = e.el && n.currentTarget === e.el;
            (!o(t) && n.currentTarget.matches(t) || r) && e.tour.next();
          }
        };
      }(e, n);
      let i = null;
      if (!o(n) && (i = document.querySelector(n), !i)) return void 0;
      i ? (i.addEventListener(t, r), e.on("destroy", () => i.removeEventListener(t, r))) : (document.body.addEventListener(t, r, !0), e.on("destroy", () => document.body.removeEventListener(t, r, !0)));
    }
  }
  function w(e) {
    return n(e) && "" !== e ? "-" !== e.charAt(e.length - 1) ? `${e}-` : e : "";
  }
  function y(e) {
    return null == e || !e.element || !e.on;
  }
  function v() {
    let e = Date.now();
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
      const n = (e + 16 * Math.random()) % 16 | 0;
      return e = Math.floor(e / 16), ("x" == t ? n : 3 & n | 8).toString(16);
    });
  }
  const S = Math.min,
    k = Math.max,
    _ = Math.round,
    T = Math.floor,
    L = e => ({
      x: e,
      y: e
    }),
    O = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    },
    E = {
      start: "end",
      end: "start"
    };
  function I(e, t, n) {
    return k(e, S(t, n));
  }
  function A(e, t) {
    return "function" == typeof e ? e(t) : e;
  }
  function C(e) {
    return e.split("-")[0];
  }
  function M(e) {
    return e.split("-")[1];
  }
  function P(e) {
    return "x" === e ? "y" : "x";
  }
  function F(e) {
    return "y" === e ? "height" : "width";
  }
  function R(e) {
    return ["top", "bottom"].includes(C(e)) ? "y" : "x";
  }
  function D(e) {
    return P(R(e));
  }
  function B(e) {
    return e.replace(/start|end/g, e => E[e]);
  }
  function j(e) {
    return e.replace(/left|right|bottom|top/g, e => O[e]);
  }
  function H(e) {
    return "number" != typeof e ? function (e) {
      return i({
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }, e);
    }(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function N(e) {
    const {
      x: t,
      y: n,
      width: o,
      height: r
    } = e;
    return {
      width: o,
      height: r,
      top: n,
      left: t,
      right: t + o,
      bottom: n + r,
      x: t,
      y: n
    };
  }
  const z = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"],
    V = ["mainAxis", "crossAxis", "limiter"];
  function W(e, t, n) {
    let {
      reference: o,
      floating: r
    } = e;
    const i = R(t),
      s = D(t),
      l = F(s),
      a = C(t),
      c = "y" === i,
      d = o.x + o.width / 2 - r.width / 2,
      h = o.y + o.height / 2 - r.height / 2,
      u = o[l] / 2 - r[l] / 2;
    let p;
    switch (a) {
      case "top":
        p = {
          x: d,
          y: o.y - r.height
        };
        break;
      case "bottom":
        p = {
          x: d,
          y: o.y + o.height
        };
        break;
      case "right":
        p = {
          x: o.x + o.width,
          y: h
        };
        break;
      case "left":
        p = {
          x: o.x - r.width,
          y: h
        };
        break;
      default:
        p = {
          x: o.x,
          y: o.y
        };
    }
    switch (M(t)) {
      case "start":
        p[s] -= u * (n && c ? -1 : 1);
        break;
      case "end":
        p[s] += u * (n && c ? -1 : 1);
    }
    return p;
  }
  async function q(e, t) {
    var n;
    void 0 === t && (t = {});
    const {
        x: o,
        y: r,
        platform: i,
        rects: s,
        elements: l,
        strategy: a
      } = e,
      {
        boundary: c = "clippingAncestors",
        rootBoundary: d = "viewport",
        elementContext: h = "floating",
        altBoundary: u = !1,
        padding: p = 0
      } = A(t, e),
      f = H(p),
      g = l[u ? "floating" === h ? "reference" : "floating" : h],
      m = N(await i.getClippingRect({
        element: null == (n = await (null == i.isElement ? void 0 : i.isElement(g))) || n ? g : g.contextElement || (await (null == i.getDocumentElement ? void 0 : i.getDocumentElement(l.floating))),
        boundary: c,
        rootBoundary: d,
        strategy: a
      })),
      b = "floating" === h ? {
        x: o,
        y: r,
        width: s.floating.width,
        height: s.floating.height
      } : s.reference,
      x = await (null == i.getOffsetParent ? void 0 : i.getOffsetParent(l.floating)),
      w = (await (null == i.isElement ? void 0 : i.isElement(x))) && (await (null == i.getScale ? void 0 : i.getScale(x))) || {
        x: 1,
        y: 1
      },
      y = N(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: l,
        rect: b,
        offsetParent: x,
        strategy: a
      }) : b);
    return {
      top: (m.top - y.top + f.top) / w.y,
      bottom: (y.bottom - m.bottom + f.bottom) / w.y,
      left: (m.left - y.left + f.left) / w.x,
      right: (y.right - m.right + f.right) / w.x
    };
  }
  function U(e) {
    return Z(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function Y(e) {
    var t;
    return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window;
  }
  function X(e) {
    var t;
    return null == (t = (Z(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement;
  }
  function Z(e) {
    return e instanceof Node || e instanceof Y(e).Node;
  }
  function G(e) {
    return e instanceof Element || e instanceof Y(e).Element;
  }
  function K(e) {
    return e instanceof HTMLElement || e instanceof Y(e).HTMLElement;
  }
  function J(e) {
    return "undefined" != typeof ShadowRoot && (e instanceof ShadowRoot || e instanceof Y(e).ShadowRoot);
  }
  function Q(e) {
    const {
      overflow: t,
      overflowX: n,
      overflowY: o,
      display: r
    } = ie(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(r);
  }
  function ee(e) {
    return ["table", "td", "th"].includes(U(e));
  }
  function te(e) {
    return [":popover-open", ":modal"].some(t => {
      try {
        return e.matches(t);
      } catch (e) {
        return !1;
      }
    });
  }
  function ne(e) {
    const t = oe(),
      n = G(e) ? ie(e) : e;
    return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some(e => (n.willChange || "").includes(e)) || ["paint", "layout", "strict", "content"].some(e => (n.contain || "").includes(e));
  }
  function oe() {
    return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
  }
  function re(e) {
    return ["html", "body", "#document"].includes(U(e));
  }
  function ie(e) {
    return Y(e).getComputedStyle(e);
  }
  function se(e) {
    return G(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.scrollX,
      scrollTop: e.scrollY
    };
  }
  function le(e) {
    if ("html" === U(e)) return e;
    const t = e.assignedSlot || e.parentNode || J(e) && e.host || X(e);
    return J(t) ? t.host : t;
  }
  function ae(e) {
    const t = le(e);
    return re(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : K(t) && Q(t) ? t : ae(t);
  }
  function ce(e, t, n) {
    var o;
    void 0 === t && (t = []), void 0 === n && (n = !0);
    const r = ae(e),
      i = r === (null == (o = e.ownerDocument) ? void 0 : o.body),
      s = Y(r);
    return i ? t.concat(s, s.visualViewport || [], Q(r) ? r : [], s.frameElement && n ? ce(s.frameElement) : []) : t.concat(r, ce(r, [], n));
  }
  function de(e) {
    const t = ie(e);
    let n = parseFloat(t.width) || 0,
      o = parseFloat(t.height) || 0;
    const r = K(e),
      i = r ? e.offsetWidth : n,
      s = r ? e.offsetHeight : o,
      l = _(n) !== i || _(o) !== s;
    return l && (n = i, o = s), {
      width: n,
      height: o,
      $: l
    };
  }
  function he(e) {
    return G(e) ? e : e.contextElement;
  }
  function ue(e) {
    const t = he(e);
    if (!K(t)) return L(1);
    const n = t.getBoundingClientRect(),
      {
        width: o,
        height: r,
        $: i
      } = de(t);
    let s = (i ? _(n.width) : n.width) / o,
      l = (i ? _(n.height) : n.height) / r;
    return s && Number.isFinite(s) || (s = 1), l && Number.isFinite(l) || (l = 1), {
      x: s,
      y: l
    };
  }
  const pe = L(0);
  function fe(e) {
    const t = Y(e);
    return oe() && t.visualViewport ? {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    } : pe;
  }
  function ge(e, t, n, o) {
    void 0 === t && (t = !1), void 0 === n && (n = !1);
    const r = e.getBoundingClientRect(),
      i = he(e);
    let s = L(1);
    t && (o ? G(o) && (s = ue(o)) : s = ue(e));
    const l = function (e, t, n) {
      return void 0 === t && (t = !1), !(!n || t && n !== Y(e)) && t;
    }(i, n, o) ? fe(i) : L(0);
    let a = (r.left + l.x) / s.x,
      c = (r.top + l.y) / s.y,
      d = r.width / s.x,
      h = r.height / s.y;
    if (i) {
      const e = Y(i),
        t = o && G(o) ? Y(o) : o;
      let n = e,
        r = n.frameElement;
      for (; r && o && t !== n;) {
        const e = ue(r),
          t = r.getBoundingClientRect(),
          o = ie(r),
          i = t.left + (r.clientLeft + parseFloat(o.paddingLeft)) * e.x,
          s = t.top + (r.clientTop + parseFloat(o.paddingTop)) * e.y;
        a *= e.x, c *= e.y, d *= e.x, h *= e.y, a += i, c += s, n = Y(r), r = n.frameElement;
      }
    }
    return N({
      width: d,
      height: h,
      x: a,
      y: c
    });
  }
  function me(e) {
    return ge(X(e)).left + se(e).scrollLeft;
  }
  function be(e, t, n) {
    let o;
    if ("viewport" === t) o = function (e, t) {
      const n = Y(e),
        o = X(e),
        r = n.visualViewport;
      let i = o.clientWidth,
        s = o.clientHeight,
        l = 0,
        a = 0;
      if (r) {
        i = r.width, s = r.height;
        const e = oe();
        (!e || e && "fixed" === t) && (l = r.offsetLeft, a = r.offsetTop);
      }
      return {
        width: i,
        height: s,
        x: l,
        y: a
      };
    }(e, n);else if ("document" === t) o = function (e) {
      const t = X(e),
        n = se(e),
        o = e.ownerDocument.body,
        r = k(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth),
        i = k(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
      let s = -n.scrollLeft + me(e);
      const l = -n.scrollTop;
      return "rtl" === ie(o).direction && (s += k(t.clientWidth, o.clientWidth) - r), {
        width: r,
        height: i,
        x: s,
        y: l
      };
    }(X(e));else if (G(t)) o = function (e, t) {
      const n = ge(e, !0, "fixed" === t),
        o = n.top + e.clientTop,
        r = n.left + e.clientLeft,
        i = K(e) ? ue(e) : L(1);
      return {
        width: e.clientWidth * i.x,
        height: e.clientHeight * i.y,
        x: r * i.x,
        y: o * i.y
      };
    }(t, n);else {
      const n = fe(e);
      o = i({}, t, {
        x: t.x - n.x,
        y: t.y - n.y
      });
    }
    return N(o);
  }
  function xe(e, t) {
    const n = le(e);
    return !(n === t || !G(n) || re(n)) && ("fixed" === ie(n).position || xe(n, t));
  }
  function we(e, t, n) {
    const o = K(t),
      r = X(t),
      i = "fixed" === n,
      s = ge(e, !0, i, t);
    let l = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const a = L(0);
    if (o || !o && !i) if (("body" !== U(t) || Q(r)) && (l = se(t)), o) {
      const e = ge(t, !0, i, t);
      a.x = e.x + t.clientLeft, a.y = e.y + t.clientTop;
    } else r && (a.x = me(r));
    return {
      x: s.left + l.scrollLeft - a.x,
      y: s.top + l.scrollTop - a.y,
      width: s.width,
      height: s.height
    };
  }
  function ye(e) {
    return "static" === ie(e).position;
  }
  function ve(e, t) {
    return K(e) && "fixed" !== ie(e).position ? t ? t(e) : e.offsetParent : null;
  }
  function $e(e, t) {
    const n = Y(e);
    if (te(e)) return n;
    if (!K(e)) {
      let t = le(e);
      for (; t && !re(t);) {
        if (G(t) && !ye(t)) return t;
        t = le(t);
      }
      return n;
    }
    let o = ve(e, t);
    for (; o && ee(o) && ye(o);) o = ve(o, t);
    return o && re(o) && ye(o) && !ne(o) ? n : o || function (e) {
      let t = le(e);
      for (; K(t) && !re(t);) {
        if (ne(t)) return t;
        if (te(t)) return null;
        t = le(t);
      }
      return null;
    }(e) || n;
  }
  const Se = {
    convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {
      let {
        elements: t,
        rect: n,
        offsetParent: o,
        strategy: r
      } = e;
      const i = "fixed" === r,
        s = X(o),
        l = !!t && te(t.floating);
      if (o === s || l && i) return n;
      let a = {
          scrollLeft: 0,
          scrollTop: 0
        },
        c = L(1);
      const d = L(0),
        h = K(o);
      if ((h || !h && !i) && (("body" !== U(o) || Q(s)) && (a = se(o)), K(o))) {
        const e = ge(o);
        c = ue(o), d.x = e.x + o.clientLeft, d.y = e.y + o.clientTop;
      }
      return {
        width: n.width * c.x,
        height: n.height * c.y,
        x: n.x * c.x - a.scrollLeft * c.x + d.x,
        y: n.y * c.y - a.scrollTop * c.y + d.y
      };
    },
    getDocumentElement: X,
    getClippingRect: function (e) {
      let {
        element: t,
        boundary: n,
        rootBoundary: o,
        strategy: r
      } = e;
      const i = "clippingAncestors" === n ? te(t) ? [] : function (e, t) {
          const n = t.get(e);
          if (n) return n;
          let o = ce(e, [], !1).filter(e => G(e) && "body" !== U(e)),
            r = null;
          const i = "fixed" === ie(e).position;
          let s = i ? le(e) : e;
          for (; G(s) && !re(s);) {
            const t = ie(s),
              n = ne(s);
            n || "fixed" !== t.position || (r = null), (i ? !n && !r : !n && "static" === t.position && r && ["absolute", "fixed"].includes(r.position) || Q(s) && !n && xe(e, s)) ? o = o.filter(e => e !== s) : r = t, s = le(s);
          }
          return t.set(e, o), o;
        }(t, this._c) : [].concat(n),
        s = [...i, o],
        l = s[0],
        a = s.reduce((e, n) => {
          const o = be(t, n, r);
          return e.top = k(o.top, e.top), e.right = S(o.right, e.right), e.bottom = S(o.bottom, e.bottom), e.left = k(o.left, e.left), e;
        }, be(t, l, r));
      return {
        width: a.right - a.left,
        height: a.bottom - a.top,
        x: a.left,
        y: a.top
      };
    },
    getOffsetParent: $e,
    getElementRects: async function (e) {
      const t = this.getOffsetParent || $e,
        n = this.getDimensions,
        o = await n(e.floating);
      return {
        reference: we(e.reference, await t(e.floating), e.strategy),
        floating: {
          x: 0,
          y: 0,
          width: o.width,
          height: o.height
        }
      };
    },
    getClientRects: function (e) {
      return Array.from(e.getClientRects());
    },
    getDimensions: function (e) {
      const {
        width: t,
        height: n
      } = de(e);
      return {
        width: t,
        height: n
      };
    },
    getScale: ue,
    isElement: G,
    isRTL: function (e) {
      return "rtl" === ie(e).direction;
    }
  };
  function ke(e, t, n, o) {
    void 0 === o && (o = {});
    const {
        ancestorScroll: r = !0,
        ancestorResize: s = !0,
        elementResize: l = "function" == typeof ResizeObserver,
        layoutShift: a = "function" == typeof IntersectionObserver,
        animationFrame: c = !1
      } = o,
      d = he(e),
      h = r || s ? [...(d ? ce(d) : []), ...ce(t)] : [];
    h.forEach(e => {
      r && e.addEventListener("scroll", n, {
        passive: !0
      }), s && e.addEventListener("resize", n);
    });
    const u = d && a ? function (e, t) {
      let n,
        o = null;
      const r = X(e);
      function s() {
        var e;
        clearTimeout(n), null == (e = o) || e.disconnect(), o = null;
      }
      return function l(a, c) {
        void 0 === a && (a = !1), void 0 === c && (c = 1), s();
        const {
          left: d,
          top: h,
          width: u,
          height: p
        } = e.getBoundingClientRect();
        if (a || t(), !u || !p) return;
        const f = {
          rootMargin: -T(h) + "px " + -T(r.clientWidth - (d + u)) + "px " + -T(r.clientHeight - (h + p)) + "px " + -T(d) + "px",
          threshold: k(0, S(1, c)) || 1
        };
        let g = !0;
        function m(e) {
          const t = e[0].intersectionRatio;
          if (t !== c) {
            if (!g) return l();
            t ? l(!1, t) : n = setTimeout(() => {
              l(!1, 1e-7);
            }, 1e3);
          }
          g = !1;
        }
        try {
          o = new IntersectionObserver(m, i({}, f, {
            root: r.ownerDocument
          }));
        } catch (e) {
          o = new IntersectionObserver(m, f);
        }
        o.observe(e);
      }(!0), s;
    }(d, n) : null;
    let p,
      f = -1,
      g = null;
    l && (g = new ResizeObserver(e => {
      let [o] = e;
      o && o.target === d && g && (g.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
        var e;
        null == (e = g) || e.observe(t);
      })), n();
    }), d && !c && g.observe(d), g.observe(t));
    let m = c ? ge(e) : null;
    return c && function t() {
      const o = ge(e);
      !m || o.x === m.x && o.y === m.y && o.width === m.width && o.height === m.height || n();
      m = o, p = requestAnimationFrame(t);
    }(), n(), () => {
      var e;
      h.forEach(e => {
        r && e.removeEventListener("scroll", n), s && e.removeEventListener("resize", n);
      }), null == u || u(), null == (e = g) || e.disconnect(), g = null, c && cancelAnimationFrame(p);
    };
  }
  const _e = function (e) {
      return void 0 === e && (e = {}), {
        name: "shift",
        options: e,
        async fn(t) {
          const {
              x: n,
              y: o,
              placement: r
            } = t,
            l = A(e, t),
            {
              mainAxis: a = !0,
              crossAxis: c = !1,
              limiter: d = {
                fn: e => {
                  let {
                    x: t,
                    y: n
                  } = e;
                  return {
                    x: t,
                    y: n
                  };
                }
              }
            } = l,
            h = s(l, V),
            u = {
              x: n,
              y: o
            },
            p = await q(t, h),
            f = R(C(r)),
            g = P(f);
          let m = u[g],
            b = u[f];
          if (a) {
            const e = "y" === g ? "bottom" : "right";
            m = I(m + p["y" === g ? "top" : "left"], m, m - p[e]);
          }
          if (c) {
            const e = "y" === f ? "bottom" : "right";
            b = I(b + p["y" === f ? "top" : "left"], b, b - p[e]);
          }
          const x = d.fn(i({}, t, {
            [g]: m,
            [f]: b
          }));
          return i({}, x, {
            data: {
              x: x.x - n,
              y: x.y - o
            }
          });
        }
      };
    },
    Te = function (e) {
      return void 0 === e && (e = {}), {
        name: "flip",
        options: e,
        async fn(t) {
          var n, o;
          const {
              placement: r,
              middlewareData: i,
              rects: l,
              initialPlacement: a,
              platform: c,
              elements: d
            } = t,
            h = A(e, t),
            {
              mainAxis: u = !0,
              crossAxis: p = !0,
              fallbackPlacements: f,
              fallbackStrategy: g = "bestFit",
              fallbackAxisSideDirection: m = "none",
              flipAlignment: b = !0
            } = h,
            x = s(h, z);
          if (null != (n = i.arrow) && n.alignmentOffset) return {};
          const w = C(r),
            y = R(a),
            v = C(a) === a,
            $ = await (null == c.isRTL ? void 0 : c.isRTL(d.floating)),
            S = f || (v || !b ? [j(a)] : function (e) {
              const t = j(e);
              return [B(e), t, B(t)];
            }(a)),
            k = "none" !== m;
          !f && k && S.push(...function (e, t, n, o) {
            const r = M(e);
            let i = function (e, t, n) {
              const o = ["left", "right"],
                r = ["right", "left"],
                i = ["top", "bottom"],
                s = ["bottom", "top"];
              switch (e) {
                case "top":
                case "bottom":
                  return n ? t ? r : o : t ? o : r;
                case "left":
                case "right":
                  return t ? i : s;
                default:
                  return [];
              }
            }(C(e), "start" === n, o);
            return r && (i = i.map(e => e + "-" + r), t && (i = i.concat(i.map(B)))), i;
          }(a, b, m, $));
          const _ = [a, ...S],
            T = await q(t, x),
            L = [];
          let O = (null == (o = i.flip) ? void 0 : o.overflows) || [];
          if (u && L.push(T[w]), p) {
            const e = function (e, t, n) {
              void 0 === n && (n = !1);
              const o = M(e),
                r = D(e),
                i = F(r);
              let s = "x" === r ? o === (n ? "end" : "start") ? "right" : "left" : "start" === o ? "bottom" : "top";
              return t.reference[i] > t.floating[i] && (s = j(s)), [s, j(s)];
            }(r, l, $);
            L.push(T[e[0]], T[e[1]]);
          }
          if (O = [...O, {
            placement: r,
            overflows: L
          }], !L.every(e => e <= 0)) {
            var E, I;
            const e = ((null == (E = i.flip) ? void 0 : E.index) || 0) + 1,
              t = _[e];
            if (t) return {
              data: {
                index: e,
                overflows: O
              },
              reset: {
                placement: t
              }
            };
            let n = null == (I = O.filter(e => e.overflows[0] <= 0).sort((e, t) => e.overflows[1] - t.overflows[1])[0]) ? void 0 : I.placement;
            if (!n) switch (g) {
              case "bestFit":
                {
                  var P;
                  const e = null == (P = O.filter(e => {
                    if (k) {
                      const t = R(e.placement);
                      return t === y || "y" === t;
                    }
                    return !0;
                  }).map(e => [e.placement, e.overflows.filter(e => e > 0).reduce((e, t) => e + t, 0)]).sort((e, t) => e[1] - t[1])[0]) ? void 0 : P[0];
                  e && (n = e);
                  break;
                }
              case "initialPlacement":
                n = a;
            }
            if (r !== n) return {
              reset: {
                placement: n
              }
            };
          }
          return {};
        }
      };
    },
    Le = e => ({
      name: "arrow",
      options: e,
      async fn(t) {
        const {
            x: n,
            y: o,
            placement: r,
            rects: s,
            platform: l,
            elements: a,
            middlewareData: c
          } = t,
          {
            element: d,
            padding: h = 0
          } = A(e, t) || {};
        if (null == d) return {};
        const u = H(h),
          p = {
            x: n,
            y: o
          },
          f = D(r),
          g = F(f),
          m = await l.getDimensions(d),
          b = "y" === f,
          x = b ? "top" : "left",
          w = b ? "bottom" : "right",
          y = b ? "clientHeight" : "clientWidth",
          v = s.reference[g] + s.reference[f] - p[f] - s.floating[g],
          $ = p[f] - s.reference[f],
          k = await (null == l.getOffsetParent ? void 0 : l.getOffsetParent(d));
        let _ = k ? k[y] : 0;
        _ && (await (null == l.isElement ? void 0 : l.isElement(k))) || (_ = a.floating[y] || s.floating[g]);
        const T = v / 2 - $ / 2,
          L = _ / 2 - m[g] / 2 - 1,
          O = S(u[x], L),
          E = S(u[w], L),
          C = O,
          P = _ - m[g] - E,
          R = _ / 2 - m[g] / 2 + T,
          B = I(C, R, P),
          j = !c.arrow && null != M(r) && R !== B && s.reference[g] / 2 - (R < C ? O : E) - m[g] / 2 < 0,
          N = j ? R < C ? R - C : R - P : 0;
        return {
          [f]: p[f] + N,
          data: i({
            [f]: B,
            centerOffset: R - B - N
          }, j && {
            alignmentOffset: N
          }),
          reset: j
        };
      }
    }),
    Oe = function (e) {
      return void 0 === e && (e = {}), {
        options: e,
        fn(t) {
          const {
              x: n,
              y: o,
              placement: r,
              rects: s,
              middlewareData: l
            } = t,
            {
              offset: a = 0,
              mainAxis: c = !0,
              crossAxis: d = !0
            } = A(e, t),
            h = {
              x: n,
              y: o
            },
            u = R(r),
            p = P(u);
          let f = h[p],
            g = h[u];
          const m = A(a, t),
            b = "number" == typeof m ? {
              mainAxis: m,
              crossAxis: 0
            } : i({
              mainAxis: 0,
              crossAxis: 0
            }, m);
          if (c) {
            const e = "y" === p ? "height" : "width",
              t = s.reference[p] - s.floating[e] + b.mainAxis,
              n = s.reference[p] + s.reference[e] - b.mainAxis;
            f < t ? f = t : f > n && (f = n);
          }
          if (d) {
            var x, w;
            const e = "y" === p ? "width" : "height",
              t = ["top", "left"].includes(C(r)),
              n = s.reference[u] - s.floating[e] + (t && (null == (x = l.offset) ? void 0 : x[u]) || 0) + (t ? 0 : b.crossAxis),
              o = s.reference[u] + s.reference[e] + (t ? 0 : (null == (w = l.offset) ? void 0 : w[u]) || 0) - (t ? b.crossAxis : 0);
            g < n ? g = n : g > o && (g = o);
          }
          return {
            [p]: f,
            [u]: g
          };
        }
      };
    },
    Ee = (e, t, n) => {
      const o = new Map(),
        r = i({
          platform: Se
        }, n),
        s = i({}, r.platform, {
          _c: o
        });
      return (async (e, t, n) => {
        const {
            placement: o = "bottom",
            strategy: r = "absolute",
            middleware: s = [],
            platform: l
          } = n,
          a = s.filter(Boolean),
          c = await (null == l.isRTL ? void 0 : l.isRTL(t));
        let d = await l.getElementRects({
            reference: e,
            floating: t,
            strategy: r
          }),
          {
            x: h,
            y: u
          } = W(d, o, c),
          p = o,
          f = {},
          g = 0;
        for (let n = 0; n < a.length; n++) {
          const {
              name: s,
              fn: m
            } = a[n],
            {
              x: b,
              y: x,
              data: w,
              reset: y
            } = await m({
              x: h,
              y: u,
              initialPlacement: o,
              placement: p,
              strategy: r,
              middlewareData: f,
              rects: d,
              platform: l,
              elements: {
                reference: e,
                floating: t
              }
            });
          h = null != b ? b : h, u = null != x ? x : u, f = i({}, f, {
            [s]: i({}, f[s], w)
          }), y && g <= 50 && (g++, "object" == typeof y && (y.placement && (p = y.placement), y.rects && (d = !0 === y.rects ? await l.getElementRects({
            reference: e,
            floating: t,
            strategy: r
          }) : y.rects), ({
            x: h,
            y: u
          } = W(d, p, c))), n = -1);
        }
        return {
          x: h,
          y: u,
          placement: p,
          strategy: r,
          middlewareData: f
        };
      })(e, t, i({}, r, {
        platform: s
      }));
    };
  function Ie(t) {
    t.cleanup && t.cleanup();
    const n = t._getResolvedAttachToOptions();
    let o = n.element;
    const r = function (e, t) {
        const n = {
            strategy: "absolute",
            middleware: []
          },
          o = function (e) {
            if (e.options.arrow && e.el) return e.el.querySelector(".shepherd-arrow");
            return !1;
          }(t),
          r = y(e);
        if (!r) {
          if (n.middleware.push(Te(), _e({
            limiter: Oe(),
            crossAxis: !0
          })), o) {
            var i, s;
            const t = (null == e || null == (i = e.on) ? void 0 : i.includes("-start")) || (null == e || null == (s = e.on) ? void 0 : s.includes("-end"));
            n.middleware.push(Le({
              element: o,
              padding: t ? 4 : 0
            }));
          }
          n.placement = e.on;
        }
        return f(t.options.floatingUIOptions || {}, n);
      }(n, t),
      i = y(n);
    if (i) {
      o = document.body;
      t.shepherdElementComponent.getElement().classList.add("shepherd-centered");
    }
    return t.cleanup = ke(o, t.el, () => {
      t.el ? function (t, n, o, r) {
        Ee(t, n.el, o).then(function (t, n) {
          return ({
            x: o,
            y: r,
            placement: i,
            middlewareData: s
          }) => t.el ? (n ? Object.assign(t.el.style, {
            position: "fixed",
            left: "50%",
            top: "50%",
            transform: "translate(-50%, -50%)"
          }) : Object.assign(t.el.style, {
            position: "absolute",
            left: `${o}px`,
            top: `${r}px`
          }), t.el.dataset.popperPlacement = i, function (t, n) {
            const o = t.querySelector(".shepherd-arrow");
            if (e(o) && n.arrow) {
              const {
                x: e,
                y: t
              } = n.arrow;
              Object.assign(o.style, {
                left: null != e ? `${e}px` : "",
                top: null != t ? `${t}px` : ""
              });
            }
          }(t.el, s), t) : t;
        }(n, r)).then(e => new Promise(t => {
          setTimeout(() => t(e), 300);
        })).then(e => {
          null != e && e.el && e.el.focus({
            preventScroll: !0
          });
        });
      }(o, t, r, i) : null == t.cleanup || t.cleanup();
    }), t.target = n.element, r;
  }
  function Ae() {}
  function Ce(e, t) {
    for (const n in t) e[n] = t[n];
    return e;
  }
  function Me(e) {
    return e();
  }
  function Pe() {
    return Object.create(null);
  }
  function Fe(e) {
    e.forEach(Me);
  }
  function Re(e) {
    return "function" == typeof e;
  }
  function De(e, t) {
    return e != e ? t == t : e !== t || e && "object" == typeof e || "function" == typeof e;
  }
  function Be(e, t) {
    e.appendChild(t);
  }
  function je(e, t, n) {
    e.insertBefore(t, n || null);
  }
  function He(e) {
    e.parentNode && e.parentNode.removeChild(e);
  }
  function Ne(e) {
    return document.createElement(e);
  }
  function ze(e) {
    return document.createElementNS("http://www.w3.org/2000/svg", e);
  }
  function Ve(e) {
    return document.createTextNode(e);
  }
  function We() {
    return Ve(" ");
  }
  function qe(e, t, n, o) {
    return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);
  }
  function Ue(e, t, n) {
    null == n ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
  }
  const Ye = ["width", "height"];
  function Xe(e, t) {
    const n = Object.getOwnPropertyDescriptors(e.__proto__);
    for (const o in t) null == t[o] ? e.removeAttribute(o) : "style" === o ? e.style.cssText = t[o] : "__value" === o ? e.value = e[o] = t[o] : n[o] && n[o].set && -1 === Ye.indexOf(o) ? e[o] = t[o] : Ue(e, o, t[o]);
  }
  function Ze(e, t, n) {
    e.classList.toggle(t, !!n);
  }
  let Ge;
  function Ke(e) {
    Ge = e;
  }
  function Je() {
    if (!Ge) throw new Error("Function called outside component initialization");
    return Ge;
  }
  function Qe(e) {
    Je().$$.after_update.push(e);
  }
  const et = [],
    tt = [];
  let nt = [];
  const ot = [],
    rt = Promise.resolve();
  let it = !1;
  function st(e) {
    nt.push(e);
  }
  const lt = new Set();
  let at = 0;
  function ct() {
    if (0 !== at) return;
    const e = Ge;
    do {
      try {
        for (; at < et.length;) {
          const e = et[at];
          at++, Ke(e), dt(e.$$);
        }
      } catch (e) {
        throw et.length = 0, at = 0, e;
      }
      for (Ke(null), et.length = 0, at = 0; tt.length;) tt.pop()();
      for (let e = 0; e < nt.length; e += 1) {
        const t = nt[e];
        lt.has(t) || (lt.add(t), t());
      }
      nt.length = 0;
    } while (et.length);
    for (; ot.length;) ot.pop()();
    it = !1, lt.clear(), Ke(e);
  }
  function dt(e) {
    if (null !== e.fragment) {
      e.update(), Fe(e.before_update);
      const t = e.dirty;
      e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(st);
    }
  }
  const ht = new Set();
  let ut;
  function pt() {
    ut = {
      r: 0,
      c: [],
      p: ut
    };
  }
  function ft() {
    ut.r || Fe(ut.c), ut = ut.p;
  }
  function gt(e, t) {
    e && e.i && (ht.delete(e), e.i(t));
  }
  function mt(e, t, n, o) {
    if (e && e.o) {
      if (ht.has(e)) return;
      ht.add(e), ut.c.push(() => {
        ht.delete(e), o && (n && e.d(1), o());
      }), e.o(t);
    } else o && o();
  }
  function bt(e) {
    return void 0 !== (null == e ? void 0 : e.length) ? e : Array.from(e);
  }
  function xt(e) {
    e && e.c();
  }
  function wt(e, t, n) {
    const {
      fragment: o,
      after_update: r
    } = e.$$;
    o && o.m(t, n), st(() => {
      const t = e.$$.on_mount.map(Me).filter(Re);
      e.$$.on_destroy ? e.$$.on_destroy.push(...t) : Fe(t), e.$$.on_mount = [];
    }), r.forEach(st);
  }
  function yt(e, t) {
    const n = e.$$;
    null !== n.fragment && (!function (e) {
      const t = [],
        n = [];
      nt.forEach(o => -1 === e.indexOf(o) ? t.push(o) : n.push(o)), n.forEach(e => e()), nt = t;
    }(n.after_update), Fe(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
  }
  function vt(e, t) {
    -1 === e.$$.dirty[0] && (et.push(e), it || (it = !0, rt.then(ct)), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
  }
  function $t(e, t, n, o, r, i, s = null, l = [-1]) {
    const a = Ge;
    Ke(e);
    const c = e.$$ = {
      fragment: null,
      ctx: [],
      props: i,
      update: Ae,
      not_equal: r,
      bound: Pe(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(t.context || (a ? a.$$.context : [])),
      callbacks: Pe(),
      dirty: l,
      skip_bound: !1,
      root: t.target || a.$$.root
    };
    s && s(c.root);
    let d = !1;
    if (c.ctx = n ? n(e, t.props || {}, (t, n, ...o) => {
      const i = o.length ? o[0] : n;
      return c.ctx && r(c.ctx[t], c.ctx[t] = i) && (!c.skip_bound && c.bound[t] && c.bound[t](i), d && vt(e, t)), n;
    }) : [], c.update(), d = !0, Fe(c.before_update), c.fragment = !!o && o(c.ctx), t.target) {
      if (t.hydrate) {
        const e = function (e) {
          return Array.from(e.childNodes);
        }(t.target);
        c.fragment && c.fragment.l(e), e.forEach(He);
      } else c.fragment && c.fragment.c();
      t.intro && gt(e.$$.fragment), wt(e, t.target, t.anchor), ct();
    }
    Ke(a);
  }
  class St {
    constructor() {
      this.$$ = void 0, this.$$set = void 0;
    }
    $destroy() {
      yt(this, 1), this.$destroy = Ae;
    }
    $on(e, t) {
      if (!Re(t)) return Ae;
      const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
      return n.push(t), () => {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      };
    }
    $set(e) {
      var t;
      this.$$set && (t = e, 0 !== Object.keys(t).length) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
    }
  }
  function kt(e) {
    let t, n, o, r, i;
    return {
      c() {
        t = Ne("button"), Ue(t, "aria-label", n = e[3] ? e[3] : null), Ue(t, "class", o = `${e[1] || ""} shepherd-button ${e[4] ? "shepherd-button-secondary" : ""}`), t.disabled = e[2], Ue(t, "tabindex", "0"), Ue(t, "type", "button");
      },
      m(n, o) {
        je(n, t, o), t.innerHTML = e[5], r || (i = qe(t, "click", function () {
          Re(e[0]) && e[0].apply(this, arguments);
        }), r = !0);
      },
      p(r, [i]) {
        e = r, 32 & i && (t.innerHTML = e[5]), 8 & i && n !== (n = e[3] ? e[3] : null) && Ue(t, "aria-label", n), 18 & i && o !== (o = `${e[1] || ""} shepherd-button ${e[4] ? "shepherd-button-secondary" : ""}`) && Ue(t, "class", o), 4 & i && (t.disabled = e[2]);
      },
      i: Ae,
      o: Ae,
      d(e) {
        e && He(t), r = !1, i();
      }
    };
  }
  function _t(e, n, o) {
    let r,
      i,
      s,
      l,
      a,
      c,
      {
        config: d,
        step: h
      } = n;
    function u(e) {
      return t(e) ? e.call(h) : e;
    }
    return e.$$set = e => {
      "config" in e && o(6, d = e.config), "step" in e && o(7, h = e.step);
    }, e.$$.update = () => {
      192 & e.$$.dirty && (o(0, r = d.action ? d.action.bind(h.tour) : null), o(1, i = d.classes), o(2, s = !!d.disabled && u(d.disabled)), o(3, l = d.label ? u(d.label) : null), o(4, a = d.secondary), o(5, c = d.text ? u(d.text) : null));
    }, [r, i, s, l, a, c, d, h];
  }
  "undefined" != typeof window && (window.__svelte || (window.__svelte = {
    v: new Set()
  })).v.add("4");
  class Tt extends St {
    constructor(e) {
      super(), $t(this, e, _t, kt, De, {
        config: 6,
        step: 7
      });
    }
  }
  function Lt(e, t, n) {
    const o = e.slice();
    return o[2] = t[n], o;
  }
  function Ot(e) {
    let t,
      n,
      o = bt(e[1]),
      r = [];
    for (let t = 0; t < o.length; t += 1) r[t] = Et(Lt(e, o, t));
    const i = e => mt(r[e], 1, 1, () => {
      r[e] = null;
    });
    return {
      c() {
        for (let e = 0; e < r.length; e += 1) r[e].c();
        t = Ve("");
      },
      m(e, o) {
        for (let t = 0; t < r.length; t += 1) r[t] && r[t].m(e, o);
        je(e, t, o), n = !0;
      },
      p(e, n) {
        if (3 & n) {
          let s;
          for (o = bt(e[1]), s = 0; s < o.length; s += 1) {
            const i = Lt(e, o, s);
            r[s] ? (r[s].p(i, n), gt(r[s], 1)) : (r[s] = Et(i), r[s].c(), gt(r[s], 1), r[s].m(t.parentNode, t));
          }
          for (pt(), s = o.length; s < r.length; s += 1) i(s);
          ft();
        }
      },
      i(e) {
        if (!n) {
          for (let e = 0; e < o.length; e += 1) gt(r[e]);
          n = !0;
        }
      },
      o(e) {
        r = r.filter(Boolean);
        for (let e = 0; e < r.length; e += 1) mt(r[e]);
        n = !1;
      },
      d(e) {
        e && He(t), function (e, t) {
          for (let n = 0; n < e.length; n += 1) e[n] && e[n].d(t);
        }(r, e);
      }
    };
  }
  function Et(e) {
    let t, n;
    return t = new Tt({
      props: {
        config: e[2],
        step: e[0]
      }
    }), {
      c() {
        xt(t.$$.fragment);
      },
      m(e, o) {
        wt(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        2 & n && (o.config = e[2]), 1 & n && (o.step = e[0]), t.$set(o);
      },
      i(e) {
        n || (gt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        mt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        yt(t, e);
      }
    };
  }
  function It(e) {
    let t,
      n,
      o = e[1] && Ot(e);
    return {
      c() {
        t = Ne("footer"), o && o.c(), Ue(t, "class", "shepherd-footer");
      },
      m(e, r) {
        je(e, t, r), o && o.m(t, null), n = !0;
      },
      p(e, [n]) {
        e[1] ? o ? (o.p(e, n), 2 & n && gt(o, 1)) : (o = Ot(e), o.c(), gt(o, 1), o.m(t, null)) : o && (pt(), mt(o, 1, 1, () => {
          o = null;
        }), ft());
      },
      i(e) {
        n || (gt(o), n = !0);
      },
      o(e) {
        mt(o), n = !1;
      },
      d(e) {
        e && He(t), o && o.d();
      }
    };
  }
  function At(e, t, n) {
    let o,
      {
        step: r
      } = t;
    return e.$$set = e => {
      "step" in e && n(0, r = e.step);
    }, e.$$.update = () => {
      1 & e.$$.dirty && n(1, o = r.options.buttons);
    }, [r, o];
  }
  class Ct extends St {
    constructor(e) {
      super(), $t(this, e, At, It, De, {
        step: 0
      });
    }
  }
  function Mt(e) {
    let t, n, o, r, i;
    return {
      c() {
        t = Ne("button"), n = Ne("span"), n.textContent = "Ã—", Ue(n, "aria-hidden", "true"), Ue(t, "aria-label", o = e[0].label ? e[0].label : "Close Tour"), Ue(t, "class", "shepherd-cancel-icon"), Ue(t, "type", "button");
      },
      m(o, s) {
        je(o, t, s), Be(t, n), r || (i = qe(t, "click", e[1]), r = !0);
      },
      p(e, [n]) {
        1 & n && o !== (o = e[0].label ? e[0].label : "Close Tour") && Ue(t, "aria-label", o);
      },
      i: Ae,
      o: Ae,
      d(e) {
        e && He(t), r = !1, i();
      }
    };
  }
  function Pt(e, t, n) {
    let {
      cancelIcon: o,
      step: r
    } = t;
    return e.$$set = e => {
      "cancelIcon" in e && n(0, o = e.cancelIcon), "step" in e && n(2, r = e.step);
    }, [o, e => {
      e.preventDefault(), r.cancel();
    }, r];
  }
  class Ft extends St {
    constructor(e) {
      super(), $t(this, e, Pt, Mt, De, {
        cancelIcon: 0,
        step: 2
      });
    }
  }
  function Rt(e) {
    let t;
    return {
      c() {
        t = Ne("h3"), Ue(t, "id", e[1]), Ue(t, "class", "shepherd-title");
      },
      m(n, o) {
        je(n, t, o), e[3](t);
      },
      p(e, [n]) {
        2 & n && Ue(t, "id", e[1]);
      },
      i: Ae,
      o: Ae,
      d(n) {
        n && He(t), e[3](null);
      }
    };
  }
  function Dt(e, n, o) {
    let {
      labelId: r,
      element: i,
      title: s
    } = n;
    return Qe(() => {
      t(s) && o(2, s = s()), o(0, i.innerHTML = s, i);
    }), e.$$set = e => {
      "labelId" in e && o(1, r = e.labelId), "element" in e && o(0, i = e.element), "title" in e && o(2, s = e.title);
    }, [i, r, s, function (e) {
      tt[e ? "unshift" : "push"](() => {
        i = e, o(0, i);
      });
    }];
  }
  class Bt extends St {
    constructor(e) {
      super(), $t(this, e, Dt, Rt, De, {
        labelId: 1,
        element: 0,
        title: 2
      });
    }
  }
  function jt(e) {
    let t, n;
    return t = new Bt({
      props: {
        labelId: e[0],
        title: e[2]
      }
    }), {
      c() {
        xt(t.$$.fragment);
      },
      m(e, o) {
        wt(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        1 & n && (o.labelId = e[0]), 4 & n && (o.title = e[2]), t.$set(o);
      },
      i(e) {
        n || (gt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        mt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        yt(t, e);
      }
    };
  }
  function Ht(e) {
    let t, n;
    return t = new Ft({
      props: {
        cancelIcon: e[3],
        step: e[1]
      }
    }), {
      c() {
        xt(t.$$.fragment);
      },
      m(e, o) {
        wt(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        8 & n && (o.cancelIcon = e[3]), 2 & n && (o.step = e[1]), t.$set(o);
      },
      i(e) {
        n || (gt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        mt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        yt(t, e);
      }
    };
  }
  function Nt(e) {
    let t,
      n,
      o,
      r = e[2] && jt(e),
      i = e[3] && e[3].enabled && Ht(e);
    return {
      c() {
        t = Ne("header"), r && r.c(), n = We(), i && i.c(), Ue(t, "class", "shepherd-header");
      },
      m(e, s) {
        je(e, t, s), r && r.m(t, null), Be(t, n), i && i.m(t, null), o = !0;
      },
      p(e, [o]) {
        e[2] ? r ? (r.p(e, o), 4 & o && gt(r, 1)) : (r = jt(e), r.c(), gt(r, 1), r.m(t, n)) : r && (pt(), mt(r, 1, 1, () => {
          r = null;
        }), ft()), e[3] && e[3].enabled ? i ? (i.p(e, o), 8 & o && gt(i, 1)) : (i = Ht(e), i.c(), gt(i, 1), i.m(t, null)) : i && (pt(), mt(i, 1, 1, () => {
          i = null;
        }), ft());
      },
      i(e) {
        o || (gt(r), gt(i), o = !0);
      },
      o(e) {
        mt(r), mt(i), o = !1;
      },
      d(e) {
        e && He(t), r && r.d(), i && i.d();
      }
    };
  }
  function zt(e, t, n) {
    let o,
      r,
      {
        labelId: i,
        step: s
      } = t;
    return e.$$set = e => {
      "labelId" in e && n(0, i = e.labelId), "step" in e && n(1, s = e.step);
    }, e.$$.update = () => {
      2 & e.$$.dirty && (n(2, o = s.options.title), n(3, r = s.options.cancelIcon));
    }, [i, s, o, r];
  }
  class Vt extends St {
    constructor(e) {
      super(), $t(this, e, zt, Nt, De, {
        labelId: 0,
        step: 1
      });
    }
  }
  function Wt(e) {
    let t;
    return {
      c() {
        t = Ne("div"), Ue(t, "class", "shepherd-text"), Ue(t, "id", e[1]);
      },
      m(n, o) {
        je(n, t, o), e[3](t);
      },
      p(e, [n]) {
        2 & n && Ue(t, "id", e[1]);
      },
      i: Ae,
      o: Ae,
      d(n) {
        n && He(t), e[3](null);
      }
    };
  }
  function qt(n, o, r) {
    let {
      descriptionId: i,
      element: s,
      step: l
    } = o;
    return Qe(() => {
      let {
        text: n
      } = l.options;
      t(n) && (n = n.call(l)), e(n) ? s.appendChild(n) : r(0, s.innerHTML = n, s);
    }), n.$$set = e => {
      "descriptionId" in e && r(1, i = e.descriptionId), "element" in e && r(0, s = e.element), "step" in e && r(2, l = e.step);
    }, [s, i, l, function (e) {
      tt[e ? "unshift" : "push"](() => {
        s = e, r(0, s);
      });
    }];
  }
  class Ut extends St {
    constructor(e) {
      super(), $t(this, e, qt, Wt, De, {
        descriptionId: 1,
        element: 0,
        step: 2
      });
    }
  }
  function Yt(e) {
    let t, n;
    return t = new Vt({
      props: {
        labelId: e[1],
        step: e[2]
      }
    }), {
      c() {
        xt(t.$$.fragment);
      },
      m(e, o) {
        wt(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        2 & n && (o.labelId = e[1]), 4 & n && (o.step = e[2]), t.$set(o);
      },
      i(e) {
        n || (gt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        mt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        yt(t, e);
      }
    };
  }
  function Xt(e) {
    let t, n;
    return t = new Ut({
      props: {
        descriptionId: e[0],
        step: e[2]
      }
    }), {
      c() {
        xt(t.$$.fragment);
      },
      m(e, o) {
        wt(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        1 & n && (o.descriptionId = e[0]), 4 & n && (o.step = e[2]), t.$set(o);
      },
      i(e) {
        n || (gt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        mt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        yt(t, e);
      }
    };
  }
  function Zt(e) {
    let t, n;
    return t = new Ct({
      props: {
        step: e[2]
      }
    }), {
      c() {
        xt(t.$$.fragment);
      },
      m(e, o) {
        wt(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        4 & n && (o.step = e[2]), t.$set(o);
      },
      i(e) {
        n || (gt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        mt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        yt(t, e);
      }
    };
  }
  function Gt(e) {
    let t,
      n,
      r,
      i,
      s = !o(e[2].options.title) || e[2].options.cancelIcon && e[2].options.cancelIcon.enabled,
      l = !o(e[2].options.text),
      a = Array.isArray(e[2].options.buttons) && e[2].options.buttons.length,
      c = s && Yt(e),
      d = l && Xt(e),
      h = a && Zt(e);
    return {
      c() {
        t = Ne("div"), c && c.c(), n = We(), d && d.c(), r = We(), h && h.c(), Ue(t, "class", "shepherd-content");
      },
      m(e, o) {
        je(e, t, o), c && c.m(t, null), Be(t, n), d && d.m(t, null), Be(t, r), h && h.m(t, null), i = !0;
      },
      p(e, [i]) {
        4 & i && (s = !o(e[2].options.title) || e[2].options.cancelIcon && e[2].options.cancelIcon.enabled), s ? c ? (c.p(e, i), 4 & i && gt(c, 1)) : (c = Yt(e), c.c(), gt(c, 1), c.m(t, n)) : c && (pt(), mt(c, 1, 1, () => {
          c = null;
        }), ft()), 4 & i && (l = !o(e[2].options.text)), l ? d ? (d.p(e, i), 4 & i && gt(d, 1)) : (d = Xt(e), d.c(), gt(d, 1), d.m(t, r)) : d && (pt(), mt(d, 1, 1, () => {
          d = null;
        }), ft()), 4 & i && (a = Array.isArray(e[2].options.buttons) && e[2].options.buttons.length), a ? h ? (h.p(e, i), 4 & i && gt(h, 1)) : (h = Zt(e), h.c(), gt(h, 1), h.m(t, null)) : h && (pt(), mt(h, 1, 1, () => {
          h = null;
        }), ft());
      },
      i(e) {
        i || (gt(c), gt(d), gt(h), i = !0);
      },
      o(e) {
        mt(c), mt(d), mt(h), i = !1;
      },
      d(e) {
        e && He(t), c && c.d(), d && d.d(), h && h.d();
      }
    };
  }
  function Kt(e, t, n) {
    let {
      descriptionId: o,
      labelId: r,
      step: i
    } = t;
    return e.$$set = e => {
      "descriptionId" in e && n(0, o = e.descriptionId), "labelId" in e && n(1, r = e.labelId), "step" in e && n(2, i = e.step);
    }, [o, r, i];
  }
  class Jt extends St {
    constructor(e) {
      super(), $t(this, e, Kt, Gt, De, {
        descriptionId: 0,
        labelId: 1,
        step: 2
      });
    }
  }
  function Qt(e) {
    let t;
    return {
      c() {
        t = Ne("div"), Ue(t, "class", "shepherd-arrow"), Ue(t, "data-popper-arrow", "");
      },
      m(e, n) {
        je(e, t, n);
      },
      d(e) {
        e && He(t);
      }
    };
  }
  function en(e) {
    let t,
      n,
      r,
      i,
      s,
      l,
      a,
      c,
      d = e[4].options.arrow && e[4].options.attachTo && e[4].options.attachTo.element && e[4].options.attachTo.on && Qt();
    r = new Jt({
      props: {
        descriptionId: e[2],
        labelId: e[3],
        step: e[4]
      }
    });
    let h = [{
        "aria-describedby": i = o(e[4].options.text) ? null : e[2]
      }, {
        "aria-labelledby": s = e[4].options.title ? e[3] : null
      }, e[1], {
        role: "dialog"
      }, {
        tabindex: "0"
      }],
      u = {};
    for (let e = 0; e < h.length; e += 1) u = Ce(u, h[e]);
    return {
      c() {
        t = Ne("div"), d && d.c(), n = We(), xt(r.$$.fragment), Xe(t, u), Ze(t, "shepherd-has-cancel-icon", e[5]), Ze(t, "shepherd-has-title", e[6]), Ze(t, "shepherd-element", !0);
      },
      m(o, i) {
        je(o, t, i), d && d.m(t, null), Be(t, n), wt(r, t, null), e[13](t), l = !0, a || (c = qe(t, "keydown", e[7]), a = !0);
      },
      p(e, [a]) {
        e[4].options.arrow && e[4].options.attachTo && e[4].options.attachTo.element && e[4].options.attachTo.on ? d || (d = Qt(), d.c(), d.m(t, n)) : d && (d.d(1), d = null);
        const c = {};
        4 & a && (c.descriptionId = e[2]), 8 & a && (c.labelId = e[3]), 16 & a && (c.step = e[4]), r.$set(c), Xe(t, u = function (e, t) {
          const n = {},
            o = {},
            r = {
              $$scope: 1
            };
          let i = e.length;
          for (; i--;) {
            const s = e[i],
              l = t[i];
            if (l) {
              for (const e in s) e in l || (o[e] = 1);
              for (const e in l) r[e] || (n[e] = l[e], r[e] = 1);
              e[i] = l;
            } else for (const e in s) r[e] = 1;
          }
          for (const e in o) e in n || (n[e] = void 0);
          return n;
        }(h, [(!l || 20 & a && i !== (i = o(e[4].options.text) ? null : e[2])) && {
          "aria-describedby": i
        }, (!l || 24 & a && s !== (s = e[4].options.title ? e[3] : null)) && {
          "aria-labelledby": s
        }, 2 & a && e[1], {
          role: "dialog"
        }, {
          tabindex: "0"
        }])), Ze(t, "shepherd-has-cancel-icon", e[5]), Ze(t, "shepherd-has-title", e[6]), Ze(t, "shepherd-element", !0);
      },
      i(e) {
        l || (gt(r.$$.fragment, e), l = !0);
      },
      o(e) {
        mt(r.$$.fragment, e), l = !1;
      },
      d(n) {
        n && He(t), d && d.d(), yt(r), e[13](null), a = !1, c();
      }
    };
  }
  function tn(e) {
    return e.split(" ").filter(e => !!e.length);
  }
  function nn(e, t, o) {
    let r,
      i,
      s,
      {
        classPrefix: l,
        element: a,
        descriptionId: c,
        firstFocusableElement: d,
        focusableElements: h,
        labelId: u,
        lastFocusableElement: p,
        step: f,
        dataStepId: g
      } = t;
    var m;
    m = () => {
      o(1, g = {
        [`data-${l}shepherd-step-id`]: f.id
      }), o(9, h = a.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]')), o(8, d = h[0]), o(10, p = h[h.length - 1]);
    }, Je().$$.on_mount.push(m), Qe(() => {
      s !== f.options.classes && (function (e) {
        if (n(e)) {
          const t = tn(e);
          t.length && a.classList.remove(...t);
        }
      }(s), s = f.options.classes, function (e) {
        if (n(e)) {
          const t = tn(e);
          t.length && a.classList.add(...t);
        }
      }(s));
    });
    return e.$$set = e => {
      "classPrefix" in e && o(11, l = e.classPrefix), "element" in e && o(0, a = e.element), "descriptionId" in e && o(2, c = e.descriptionId), "firstFocusableElement" in e && o(8, d = e.firstFocusableElement), "focusableElements" in e && o(9, h = e.focusableElements), "labelId" in e && o(3, u = e.labelId), "lastFocusableElement" in e && o(10, p = e.lastFocusableElement), "step" in e && o(4, f = e.step), "dataStepId" in e && o(1, g = e.dataStepId);
    }, e.$$.update = () => {
      16 & e.$$.dirty && (o(5, r = f.options && f.options.cancelIcon && f.options.cancelIcon.enabled), o(6, i = f.options && f.options.title));
    }, [a, g, c, u, f, r, i, e => {
      const {
        tour: t
      } = f;
      switch (e.keyCode) {
        case 9:
          if (0 === h.length) {
            e.preventDefault();
            break;
          }
          e.shiftKey ? (document.activeElement === d || document.activeElement.classList.contains("shepherd-element")) && (e.preventDefault(), p.focus()) : document.activeElement === p && (e.preventDefault(), d.focus());
          break;
        case 27:
          t.options.exitOnEsc && (e.preventDefault(), e.stopPropagation(), f.cancel());
          break;
        case 37:
          t.options.keyboardNavigation && (e.preventDefault(), e.stopPropagation(), t.back());
          break;
        case 39:
          t.options.keyboardNavigation && (e.preventDefault(), e.stopPropagation(), t.next());
      }
    }, d, h, p, l, () => a, function (e) {
      tt[e ? "unshift" : "push"](() => {
        a = e, o(0, a);
      });
    }];
  }
  class on extends St {
    constructor(e) {
      super(), $t(this, e, nn, en, De, {
        classPrefix: 11,
        element: 0,
        descriptionId: 2,
        firstFocusableElement: 8,
        focusableElements: 9,
        labelId: 3,
        lastFocusableElement: 10,
        step: 4,
        dataStepId: 1,
        getElement: 12
      });
    }
    get getElement() {
      return this.$$.ctx[12];
    }
  }
  class rn extends r {
    constructor(e, t = {}) {
      return super(), this._resolvedAttachTo = void 0, this.classPrefix = void 0, this.el = void 0, this.target = void 0, this.tour = void 0, this.tour = e, this.classPrefix = this.tour.options ? w(this.tour.options.classPrefix) : "", this.styles = e.styles, this._resolvedAttachTo = null, b(this), this._setOptions(t), this;
    }
    cancel() {
      this.tour.cancel(), this.trigger("cancel");
    }
    complete() {
      this.tour.complete(), this.trigger("complete");
    }
    destroy() {
      var t;
      (t = this).cleanup && t.cleanup(), t.cleanup = null, e(this.el) && (this.el.remove(), this.el = null), this._updateStepTargetOnHide(), this.trigger("destroy");
    }
    getTour() {
      return this.tour;
    }
    hide() {
      var e;
      null == (e = this.tour.modal) || e.hide(), this.trigger("before-hide"), this.el && (this.el.hidden = !0), this._updateStepTargetOnHide(), this.trigger("hide");
    }
    _resolveAttachToOptions() {
      return this._resolvedAttachTo = function (e) {
        const o = e.options.attachTo || {},
          r = Object.assign({}, o);
        if (t(r.element) && (r.element = r.element.call(e)), n(r.element)) {
          try {
            r.element = document.querySelector(r.element);
          } catch (e) {}
          r.element || void 0;
        }
        return r;
      }(this), this._resolvedAttachTo;
    }
    _getResolvedAttachToOptions() {
      return null === this._resolvedAttachTo ? this._resolveAttachToOptions() : this._resolvedAttachTo;
    }
    isOpen() {
      return Boolean(this.el && !this.el.hidden);
    }
    show() {
      return t(this.options.beforeShowPromise) ? Promise.resolve(this.options.beforeShowPromise()).then(() => this._show()) : Promise.resolve(this._show());
    }
    updateStepOptions(e) {
      Object.assign(this.options, e), this.shepherdElementComponent && this.shepherdElementComponent.$set({
        step: this
      });
    }
    getElement() {
      return this.el;
    }
    getTarget() {
      return this.target;
    }
    _createTooltipContent() {
      const e = `${this.id}-description`,
        t = `${this.id}-label`;
      return this.shepherdElementComponent = new on({
        target: this.tour.options.stepsContainer || document.body,
        props: {
          classPrefix: this.classPrefix,
          descriptionId: e,
          labelId: t,
          step: this,
          styles: this.styles
        }
      }), this.shepherdElementComponent.getElement();
    }
    _scrollTo(e) {
      const {
        element: n
      } = this._getResolvedAttachToOptions();
      t(this.options.scrollToHandler) ? this.options.scrollToHandler(n) : n instanceof Element && "function" == typeof n.scrollIntoView && n.scrollIntoView(e);
    }
    _getClassOptions(e) {
      const t = this.tour && this.tour.options && this.tour.options.defaultStepOptions,
        n = e.classes ? e.classes : "",
        o = t && t.classes ? t.classes : "",
        r = [...n.split(" "), ...o.split(" ")],
        i = new Set(r);
      return Array.from(i).join(" ").trim();
    }
    _setOptions(e = {}) {
      let t = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
      t = f({}, t || {}), this.options = Object.assign({
        arrow: !0
      }, t, e, function (e, t) {
        return {
          floatingUIOptions: f(e.floatingUIOptions || {}, t.floatingUIOptions || {})
        };
      }(t, e));
      const {
        when: n
      } = this.options;
      this.options.classes = this._getClassOptions(e), this.destroy(), this.id = this.options.id || `step-${v()}`, n && Object.keys(n).forEach(e => {
        this.on(e, n[e], this);
      });
    }
    _setupElements() {
      o(this.el) || this.destroy(), this.el = this._createTooltipContent(), this.options.advanceOn && x(this), Ie(this);
    }
    _show() {
      var e;
      this.trigger("before-show"), this._resolveAttachToOptions(), this._setupElements(), this.tour.modal || this.tour.setupModal(), null == (e = this.tour.modal) || e.setupForStep(this), this._styleTargetElementForStep(this), this.el && (this.el.hidden = !1), this.options.scrollTo && setTimeout(() => {
        this._scrollTo(this.options.scrollTo);
      }), this.el && (this.el.hidden = !1);
      const t = this.shepherdElementComponent.getElement(),
        n = this.target || document.body;
      n.classList.add(`${this.classPrefix}shepherd-enabled`), n.classList.add(`${this.classPrefix}shepherd-target`), t.classList.add("shepherd-enabled"), this.trigger("show");
    }
    _styleTargetElementForStep(e) {
      const t = e.target;
      t && (e.options.highlightClass && t.classList.add(e.options.highlightClass), t.classList.remove("shepherd-target-click-disabled"), !1 === e.options.canClickTarget && t.classList.add("shepherd-target-click-disabled"));
    }
    _updateStepTargetOnHide() {
      const e = this.target || document.body;
      this.options.highlightClass && e.classList.remove(this.options.highlightClass), e.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`);
    }
  }
  function sn(e) {
    let t, n, o, r, i;
    return {
      c() {
        t = ze("svg"), n = ze("path"), Ue(n, "d", e[2]), Ue(t, "class", o = (e[1] ? "shepherd-modal-is-visible" : "") + " shepherd-modal-overlay-container");
      },
      m(o, s) {
        je(o, t, s), Be(t, n), e[11](t), r || (i = qe(t, "touchmove", e[3]), r = !0);
      },
      p(e, [r]) {
        4 & r && Ue(n, "d", e[2]), 2 & r && o !== (o = (e[1] ? "shepherd-modal-is-visible" : "") + " shepherd-modal-overlay-container") && Ue(t, "class", o);
      },
      i: Ae,
      o: Ae,
      d(n) {
        n && He(t), e[11](null), r = !1, i();
      }
    };
  }
  function ln(e) {
    if (!e) return null;
    const t = e instanceof HTMLElement && window.getComputedStyle(e).overflowY;
    return "hidden" !== t && "visible" !== t && e.scrollHeight >= e.clientHeight ? e : ln(e.parentElement);
  }
  function an(e, t, n) {
    let o,
      r,
      {
        element: i,
        openingProperties: s
      } = t,
      l = !1;
    a();
    function a() {
      n(4, s = {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        r: 0
      });
    }
    function c() {
      n(1, l = !1), p();
    }
    function d(e = 0, t = 0, o = 0, r = 0, i, l) {
      if (l) {
        const {
            y: a,
            height: c
          } = function (e, t) {
            const n = e.getBoundingClientRect();
            let o = n.y || n.top,
              r = n.bottom || o + n.height;
            if (t) {
              const e = t.getBoundingClientRect(),
                n = e.y || e.top,
                i = e.bottom || n + e.height;
              o = Math.max(o, n), r = Math.min(r, i);
            }
            return {
              y: o,
              height: Math.max(r - o, 0)
            };
          }(l, i),
          {
            x: d,
            width: h,
            left: u
          } = l.getBoundingClientRect();
        n(4, s = {
          width: h + 2 * e,
          height: c + 2 * e,
          x: (d || u) + o - e,
          y: a + r - e,
          r: t
        });
      } else a();
    }
    function h() {
      n(1, l = !0);
    }
    const u = e => {
      e.preventDefault();
    };
    function p() {
      o && (cancelAnimationFrame(o), o = void 0), window.removeEventListener("touchmove", u, {
        passive: !1
      });
    }
    return e.$$set = e => {
      "element" in e && n(0, i = e.element), "openingProperties" in e && n(4, s = e.openingProperties);
    }, e.$$.update = () => {
      16 & e.$$.dirty && n(2, r = function ({
        width: e,
        height: t,
        x: n = 0,
        y: o = 0,
        r = 0
      }) {
        const {
            innerWidth: i,
            innerHeight: s
          } = window,
          {
            topLeft: l = 0,
            topRight: a = 0,
            bottomRight: c = 0,
            bottomLeft: d = 0
          } = "number" == typeof r ? {
            topLeft: r,
            topRight: r,
            bottomRight: r,
            bottomLeft: r
          } : r;
        return `M${i},${s}H0V0H${i}V${s}ZM${n + l},${o}a${l},${l},0,0,0-${l},${l}V${t + o - d}a${d},${d},0,0,0,${d},${d}H${e + n - c}a${c},${c},0,0,0,${c}-${c}V${o + a}a${a},${a},0,0,0-${a}-${a}Z`;
      }(s));
    }, [i, l, r, e => {
      e.stopPropagation();
    }, s, () => i, a, c, d, function (e) {
      p(), e.tour.options.useModalOverlay ? (!function (e) {
        const {
            modalOverlayOpeningPadding: t,
            modalOverlayOpeningRadius: n,
            modalOverlayOpeningXOffset: r = 0,
            modalOverlayOpeningYOffset: i = 0
          } = e.options,
          s = function (e) {
            let t = {
              top: 0,
              left: 0
            };
            if (!e) return t;
            let n = e.ownerDocument.defaultView;
            for (; n !== window.top;) {
              var o;
              const e = null == (o = n) ? void 0 : o.frameElement;
              if (e) {
                var r, i;
                const n = e.getBoundingClientRect();
                t.top += n.top + (null != (r = n.scrollTop) ? r : 0), t.left += n.left + (null != (i = n.scrollLeft) ? i : 0);
              }
              n = n.parent;
            }
            return t;
          }(e.target),
          l = ln(e.target),
          a = () => {
            o = void 0, d(t, n, r + s.left, i + s.top, l, e.target), o = requestAnimationFrame(a);
          };
        a(), window.addEventListener("touchmove", u, {
          passive: !1
        });
      }(e), h()) : c();
    }, h, function (e) {
      tt[e ? "unshift" : "push"](() => {
        i = e, n(0, i);
      });
    }];
  }
  class cn extends St {
    constructor(e) {
      super(), $t(this, e, an, sn, De, {
        element: 0,
        openingProperties: 4,
        getElement: 5,
        closeModalOpening: 6,
        hide: 7,
        positionModal: 8,
        setupForStep: 9,
        show: 10
      });
    }
    get getElement() {
      return this.$$.ctx[5];
    }
    get closeModalOpening() {
      return this.$$.ctx[6];
    }
    get hide() {
      return this.$$.ctx[7];
    }
    get positionModal() {
      return this.$$.ctx[8];
    }
    get setupForStep() {
      return this.$$.ctx[9];
    }
    get show() {
      return this.$$.ctx[10];
    }
  }
  const dn = new class extends r {
      constructor() {
        super(), this.activeTour = void 0, b(this);
      }
    }(),
    hn = "undefined" == typeof window;
  dn.Step = hn ? class {
    constructor(e) {}
  } : rn, dn.Tour = hn ? class {
    constructor(e, t) {}
  } : class extends r {
    constructor(e = {}) {
      super(), this.trackedEvents = ["active", "cancel", "complete", "show"], this.classPrefix = void 0, this.currentStep = void 0, this.focusedElBeforeOpen = void 0, this.id = void 0, this.modal = void 0, this.options = void 0, this.steps = void 0, b(this);
      this.options = Object.assign({}, {
        exitOnEsc: !0,
        keyboardNavigation: !0
      }, e), this.classPrefix = w(this.options.classPrefix), this.steps = [], this.addSteps(this.options.steps);
      return ["active", "cancel", "complete", "inactive", "show", "start"].map(e => {
        (e => {
          this.on(e, t => {
            (t = t || {}).tour = this, dn.trigger(e, t);
          });
        })(e);
      }), this._setTourID(e.id), this;
    }
    addStep(e, t) {
      let n = e;
      return n instanceof rn ? n.tour = this : n = new rn(this, n), o(t) ? this.steps.push(n) : this.steps.splice(t, 0, n), n;
    }
    addSteps(e) {
      return Array.isArray(e) && e.forEach(e => {
        this.addStep(e);
      }), this;
    }
    back() {
      const e = this.steps.indexOf(this.currentStep);
      this.show(e - 1, !1);
    }
    async cancel() {
      if (this.options.confirmCancel) {
        const e = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
        let n;
        n = t(this.options.confirmCancel) ? await this.options.confirmCancel() : window.confirm(e), n && this._done("cancel");
      } else this._done("cancel");
    }
    complete() {
      this._done("complete");
    }
    getById(e) {
      return this.steps.find(t => t.id === e);
    }
    getCurrentStep() {
      return this.currentStep;
    }
    hide() {
      const e = this.getCurrentStep();
      if (e) return e.hide();
    }
    isActive() {
      return dn.activeTour === this;
    }
    next() {
      const e = this.steps.indexOf(this.currentStep);
      e === this.steps.length - 1 ? this.complete() : this.show(e + 1, !0);
    }
    removeStep(e) {
      const t = this.getCurrentStep();
      this.steps.some((t, n) => {
        if (t.id === e) return t.isOpen() && t.hide(), t.destroy(), this.steps.splice(n, 1), !0;
      }), t && t.id === e && (this.currentStep = void 0, this.steps.length ? this.show(0) : this.cancel());
    }
    show(e = 0, o = !0) {
      const r = n(e) ? this.getById(e) : this.steps[e];
      if (r) {
        this._updateStateBeforeShow();
        t(r.options.showOn) && !r.options.showOn() ? this._skipStep(r, o) : (this.trigger("show", {
          step: r,
          previous: this.currentStep
        }), this.currentStep = r, r.show());
      }
    }
    async start() {
      this.trigger("start"), this.focusedElBeforeOpen = document.activeElement, this.currentStep = null, this.setupModal(), this._setupActiveTour(), this.next();
    }
    _done(t) {
      const n = this.steps.indexOf(this.currentStep);
      if (Array.isArray(this.steps) && this.steps.forEach(e => e.destroy()), function (t) {
        if (t) {
          const {
            steps: n
          } = t;
          n.forEach(t => {
            t.options && !1 === t.options.canClickTarget && t.options.attachTo && e(t.target) && t.target.classList.remove("shepherd-target-click-disabled");
          });
        }
      }(this), this.trigger(t, {
        index: n
      }), dn.activeTour = null, this.trigger("inactive", {
        tour: this
      }), this.modal && this.modal.hide(), ("cancel" === t || "complete" === t) && this.modal) {
        const e = document.querySelector(".shepherd-modal-overlay-container");
        e && (e.remove(), this.modal = null);
      }
      e(this.focusedElBeforeOpen) && this.focusedElBeforeOpen.focus();
    }
    _setupActiveTour() {
      this.trigger("active", {
        tour: this
      }), dn.activeTour = this;
    }
    setupModal() {
      this.modal = new cn({
        target: this.options.modalContainer || document.body,
        props: {
          styles: this.styles
        }
      });
    }
    _skipStep(e, t) {
      const n = this.steps.indexOf(e);
      if (n === this.steps.length - 1) this.complete();else {
        const e = t ? n + 1 : n - 1;
        this.show(e, t);
      }
    }
    _updateStateBeforeShow() {
      this.currentStep && this.currentStep.hide(), this.isActive() || this._setupActiveTour();
    }
    _setTourID(e) {
      const t = this.options.tourName || "tour",
        n = e || v();
      this.id = `${t}--${n}`;
    }
  };
  !function (e, t) {
    void 0 === t && (t = {});
    var n = t.insertAt;
    if ("undefined" != typeof document) {
      var o = document.head || document.getElementsByTagName("head")[0],
        r = document.createElement("style");
      r.type = "text/css", "top" === n && o.firstChild ? o.insertBefore(r, o.firstChild) : o.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e));
    }
  }('.shepherd-button{background:#3288e6;border:0;border-radius:3px;color:hsla(0,0%,100%,.75);cursor:pointer;margin-right:.5rem;padding:.5rem 1.5rem;transition:all .5s ease}.shepherd-button:not(:disabled):hover{background:#196fcc;color:hsla(0,0%,100%,.75)}.shepherd-button.shepherd-button-secondary{background:#f1f2f3;color:rgba(0,0,0,.75)}.shepherd-button.shepherd-button-secondary:not(:disabled):hover{background:#d6d9db;color:rgba(0,0,0,.75)}.shepherd-button:disabled{cursor:not-allowed}.shepherd-footer{border-bottom-left-radius:5px;border-bottom-right-radius:5px;display:flex;justify-content:flex-end;padding:0 .75rem .75rem}.shepherd-footer .shepherd-button:last-child{margin-right:0}.shepherd-cancel-icon{background:transparent;border:none;color:hsla(0,0%,50%,.75);cursor:pointer;font-size:2em;font-weight:400;margin:0;padding:0;transition:color .5s ease}.shepherd-cancel-icon:hover{color:rgba(0,0,0,.75)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon{color:hsla(0,0%,50%,.75)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover{color:rgba(0,0,0,.75)}.shepherd-title{color:rgba(0,0,0,.75);display:flex;flex:1 0 auto;font-size:1rem;font-weight:400;margin:0;padding:0}.shepherd-header{align-items:center;border-top-left-radius:5px;border-top-right-radius:5px;display:flex;justify-content:flex-end;line-height:2em;padding:.75rem .75rem 0}.shepherd-has-title .shepherd-content .shepherd-header{background:#e6e6e6;padding:1em}.shepherd-text{color:rgba(0,0,0,.75);font-size:1rem;line-height:1.3em;padding:.75em}.shepherd-text p{margin-top:0}.shepherd-text p:last-child{margin-bottom:0}.shepherd-content{border-radius:5px;outline:none;padding:0}.shepherd-element{background:#fff;border-radius:5px;box-shadow:0 1px 4px rgba(0,0,0,.2);max-width:400px;opacity:0;outline:none;transition:opacity .3s,visibility .3s;visibility:hidden;width:100%;z-index:9999}.shepherd-enabled.shepherd-element{opacity:1;visibility:visible}.shepherd-element[data-popper-reference-hidden]:not(.shepherd-centered){opacity:0;pointer-events:none;visibility:hidden}.shepherd-element,.shepherd-element *,.shepherd-element :after,.shepherd-element :before{box-sizing:border-box}.shepherd-arrow,.shepherd-arrow:before{height:16px;position:absolute;width:16px;z-index:-1}.shepherd-arrow:before{background:#fff;content:"";transform:rotate(45deg)}.shepherd-element[data-popper-placement^=top]>.shepherd-arrow{bottom:-8px}.shepherd-element[data-popper-placement^=bottom]>.shepherd-arrow{top:-8px}.shepherd-element[data-popper-placement^=left]>.shepherd-arrow{right:-8px}.shepherd-element[data-popper-placement^=right]>.shepherd-arrow{left:-8px}.shepherd-element.shepherd-centered>.shepherd-arrow{opacity:0}.shepherd-element.shepherd-has-title[data-popper-placement^=bottom]>.shepherd-arrow:before{background-color:#e6e6e6}.shepherd-target-click-disabled.shepherd-enabled.shepherd-target,.shepherd-target-click-disabled.shepherd-enabled.shepherd-target *{pointer-events:none}.shepherd-modal-overlay-container{height:0;left:0;opacity:0;overflow:hidden;pointer-events:none;position:fixed;top:0;transition:all .3s ease-out,height 0ms .3s,opacity .3s 0ms;width:100vw;z-index:9997}.shepherd-modal-overlay-container.shepherd-modal-is-visible{height:100vh;opacity:.5;transform:translateZ(0);transition:all .3s ease-out,height 0s 0s,opacity .3s 0s}.shepherd-modal-overlay-container.shepherd-modal-is-visible path{pointer-events:all}.shepherd-element{border-width:1px;border-color:var(--color-background-tertiary);background-color:var(--color-background-primary);color:var(--color-text-primary);--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shepherd-element:is(.sp-theme-dark *){background-color:var(--color-background-secondary)}.shepherd-element {\n    z-index: 10005;\n}.shepherd-arrow:before{background-color:var(--color-background-primary)}.shepherd-arrow:is(.sp-theme-dark *):before{background-color:var(--color-background-secondary)}.shepherd-element.shepherd-has-title[data-popper-placement^=bottom]>.shepherd-arrow:before{background-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=top]>.shepherd-arrow:before,\n.shepherd-element.shepherd-has-title[data-popper-placement^=right]>.shepherd-arrow:before{border-bottom-width:1px;border-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=top]>.shepherd-arrow:before,\n.shepherd-element.shepherd-has-title[data-popper-placement^=left]>.shepherd-arrow:before{border-inline-end-width:1px;border-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=right]>.shepherd-arrow:before{border-inline-start-width:1px;border-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=left]>.shepherd-arrow:before{border-top-width:1px;border-color:var(--color-background-tertiary)}.shepherd-has-title .shepherd-content .shepherd-header{background-color:var(--color-background-tertiary);padding-left:1rem;padding-right:1rem;padding-top:0.5rem;padding-bottom:0.5rem}.shepherd-title{font-size:1.125rem;font-weight:700;color:var(--color-text-primary)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon{color:var(--color-text-secondary);--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover{color:var(--color-text-primary)}.shepherd-cancel-icon{font-size:1.5rem;font-weight:700}.shepherd-text{overflow:auto;color:var(--color-text-primary)}.shepherd-button{border-radius:0.25rem;background-color:var(--color-primary-800);color:var(--color-white, #fff)}.shepherd-button:not(:disabled):hover{background-color:var(--color-primary-900);color:var(--color-white, #fff)}\n'), App.extend("tour", new function () {
    var e = this,
      t = null,
      n = "supportpalProductTour",
      o = {
        defaultStepOptions: {
          scrollTo: {
            behavior: "smooth"
          },
          buttons: [{
            text: Lang.get("general.next"),
            action: function () {
              return this.next();
            }
          }],
          cancelIcon: {
            enabled: !0
          }
        }
      },
      r = [{
        id: "step-1",
        title: Lang.get("core.dashboard"),
        text: Lang.get("core.dashboard_desc")
      }, {
        id: "step-2",
        title: Lang.get("core.private_messages"),
        text: Lang.get("core.messages_desc"),
        attachTo: {
          element: "#privateMessages",
          on: "bottom"
        }
      }, {
        id: "step-3",
        title: Lang.get("core.configure"),
        text: Lang.get("core.configure_desc"),
        attachTo: {
          element: "#settingsNavigation",
          on: "bottom"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.setting");
          }
        }]
      }, {
        id: "step-4",
        title: Lang.choice("core.brand", 2),
        text: Lang.get("core.brand_desc"),
        attachTo: {
          element: "#brandSettings",
          on: "right"
        },
        when: {
          show: function () {
            Cookies.remove("generalSettingsBox"), $("#generalSettingsBox").hasClass("sp-closed") && $("#generalSettingsBox").trigger("click");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.brand.edit", {
              brand: 1
            });
          }
        }]
      }, {
        id: "step-5",
        title: Lang.get("core.brand_name"),
        text: Lang.get("core.brand_name_desc"),
        attachTo: {
          element: "#name",
          on: "bottom"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            return $("#Email").trigger("click"), this.next();
          }
        }]
      }, {
        id: "step-6",
        title: Lang.get("core.default_email"),
        text: Lang.get("core.default_email_desc"),
        attachTo: {
          element: "#default_email",
          on: "bottom"
        },
        when: {
          show: function () {
            Cookies.remove("ticketSettingsBox"), $("#generalSettingsBox").hasClass("sp-closed") || $("#generalSettingsBox").trigger("click"), $("#ticketSettingsBox").hasClass("sp-closed") && $("#ticketSettingsBox").trigger("click");
          }
        }
      }, {
        id: "step-7",
        title: Lang.choice("ticket.department", 2),
        text: Lang.get("core.department_desc"),
        attachTo: {
          element: "#ticketDeptSetting",
          on: "right"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.operator.department.edit", {
              department: 0
            });
          }
        }]
      }, {
        id: "step-8",
        title: Lang.choice("ticket.department", 2),
        text: Lang.get("core.dept_settings_desc"),
        attachTo: {
          element: "#departmentSettings",
          on: "top"
        }
      }, {
        id: "step-9",
        title: Lang.get("core.department_email"),
        text: Lang.get("core.dept_email_desc"),
        attachTo: {
          element: "#emailAccounts",
          on: "top"
        }
      }, {
        id: "step-10",
        title: Lang.get("core.dept_tmpl"),
        text: Lang.get("core.dept_tmpl_desc"),
        attachTo: {
          element: "#department-templates",
          on: "bottom"
        }
      }, {
        id: "step-11",
        title: Lang.choice("core.scheduled_task", 2),
        text: Lang.get("core.schedule_task_desc"),
        attachTo: {
          element: "#scheduledTaskSetting",
          on: "right"
        },
        when: {
          show: function () {
            $("#generalSettingsBox").hasClass("sp-closed") && $("#generalSettingsBox").trigger("click"), $("#ticketSettingsBox").hasClass("sp-closed") || $("#ticketSettingsBox").trigger("click");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.scheduledtask.index");
          }
        }]
      }, {
        id: "step-12",
        title: Lang.choice("core.scheduled_task", 2),
        text: Lang.get("core.schedule_task_2"),
        attachTo: {
          element: "#scheduledTaskTable",
          on: "top"
        }
      }, {
        id: "step-13",
        title: Lang.get("core.schedule_task_cron"),
        text: Lang.get("core.schedule_task_3"),
        attachTo: {
          element: "#scheduledTaskCron",
          on: "top"
        }
      }, {
        id: "step-14",
        title: Lang.choice("ticket.channel", 2),
        text: Lang.get("core.ticket_channel_desc"),
        attachTo: {
          element: "#channelSettings",
          on: "right"
        },
        when: {
          show: function () {
            $("#generalSettingsBox").hasClass("sp-closed") || $("#generalSettingsBox").trigger("click"), $("#ticketSettingsBox").hasClass("sp-closed") && $("#ticketSettingsBox").trigger("click");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.operator.channel.index");
          }
        }]
      }, {
        id: "step-15",
        title: Lang.choice("ticket.channel", 2),
        text: Lang.get("core.ticket_channel_2"),
        attachTo: {
          element: "#ticketChannelTable",
          on: "top"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.channel.web.settings");
          }
        }]
      }, {
        id: "step-16",
        title: Lang.get("ticket.web_settings"),
        text: Lang.get("core.web_settings_desc"),
        attachTo: {
          element: "#unauthenticated_users_label",
          on: "bottom"
        }
      }, {
        id: "step-17",
        title: Lang.choice("user.user", 2),
        text: Lang.get("core.user_desc"),
        attachTo: {
          element: "#manageUserSetting",
          on: "right"
        },
        when: {
          show: function () {
            $("#userHeaderDropdown > a").addClass("sp-hover");
          }
        }
      }, {
        id: "step-18",
        title: Lang.choice("user.organisation", 2),
        text: Lang.get("core.organisation_desc"),
        attachTo: {
          element: "#manageOrgSetting",
          on: "right"
        }
      }, {
        id: "step-19",
        title: Lang.choice("general.operator", 2),
        text: Lang.get("core.operator_desc"),
        attachTo: {
          element: "#manageOperatorSetting",
          on: "right"
        }
      }, {
        id: "step-20",
        title: Lang.choice("ticket.ticket", 2),
        text: Lang.get("core.ticket_desc"),
        attachTo: {
          element: "#manageTickets",
          on: "right"
        },
        when: {
          show: function () {
            $("#ticketHeaderDropdown > a").addClass("sp-hover"), $("#userHeaderDropdown > a").removeClass("sp-hover");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.operator.ticket");
          }
        }]
      }, {
        id: "step-21",
        title: Lang.choice("ticket.ticket", 2),
        text: Lang.get("core.ticket_desc2"),
        attachTo: {
          element: "#ticketGridTable",
          on: "top"
        },
        when: {
          show: function () {
            $("#ticketHeaderDropdown > a").removeClass("sp-hover");
          }
        }
      }, {
        id: "step-22",
        title: Lang.get("core.ticket_toolbar"),
        text: Lang.get("core.ticket_desc3"),
        attachTo: {
          element: "#openNewTicket",
          on: "bottom"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.dashboard");
          }
        }]
      }, {
        id: "step-23",
        title: Lang.get("core.tour_complete"),
        text: Lang.get("core.tour_complete_desc"),
        buttons: [{
          text: Lang.get("general.dismiss"),
          action: function () {
            return this.complete();
          }
        }]
      }],
      i = function () {
        e.clearStep(), $.post(laroute.route("core.operator.product_tour.toggle"));
      };
    this.getStep = function () {
      return localStorage.getItem(n);
    }, this.setStep = function (e) {
      localStorage.setItem(n, e);
    }, this.clearStep = function () {
      localStorage.removeItem(n);
    }, this.start = function () {
      return this.instance().start();
    }, this.show = function (e) {
      return this.instance().show("step-" + e);
    }, this.instance = function () {
      return null === t && ((t = new dn.Tour(o)).addSteps(r), t.on("complete", i), t.on("cancel", i)), t;
    }, this.instance();
  }()), $(function () {
    if (null !== App.tour.getStep()) {
      var e = [location.protocol, "//", location.host, location.pathname].join(""),
        t = parseInt(App.tour.getStep().split("-")[1]) + 1;
      e == laroute.route("core.operator.dashboard") ? $("#widgets").on("widgetsLoaded", function (e) {
        App.tour.show(t);
      }) : App.tour.show(t);
    }
  });
});