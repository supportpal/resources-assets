!function (e) {
  "function" == typeof define && define.amd ? define(e) : e();
}(function () {
  "use strict";

  /*! shepherd.js 12.0.6 */
  function e(e) {
    return e instanceof HTMLElement;
  }
  function t(e) {
    return "function" == typeof e;
  }
  function n(e) {
    return "string" == typeof e;
  }
  function o(e) {
    return void 0 === e;
  }
  class r {
    on(e, t, n, r = !1) {
      var i;
      return o(this.bindings) && (this.bindings = {}), o(this.bindings[e]) && (this.bindings[e] = []), null == (i = this.bindings[e]) || i.push({
        handler: t,
        ctx: n,
        once: r
      }), this;
    }
    once(e, t, n) {
      return this.on(e, t, n, !0);
    }
    off(e, t) {
      if (o(this.bindings) || o(this.bindings[e])) return this;
      var n;
      o(t) ? delete this.bindings[e] : null == (n = this.bindings[e]) || n.forEach((n, o) => {
        var r;
        n.handler === t && (null == (r = this.bindings[e]) || r.splice(o, 1));
      });
      return this;
    }
    trigger(e, ...t) {
      var n;
      !o(this.bindings) && this.bindings[e] && (null == (n = this.bindings[e]) || n.forEach((n, o) => {
        const {
            ctx: r,
            handler: i,
            once: s
          } = n,
          a = r || this;
        var c;
        (i.apply(a, t), s) && (null == (c = this.bindings[e]) || c.splice(o, 1));
      }));
      return this;
    }
  }
  function i(e) {
    var t, n;
    function o(t, n) {
      try {
        var i = e[t](n),
          a = i.value,
          c = a instanceof s;
        Promise.resolve(c ? a.v : a).then(function (n) {
          if (c) {
            var s = "return" === t ? "return" : "next";
            if (!a.k || n.done) return o(s, n);
            n = e[s](n).value;
          }
          r(i.done ? "return" : "normal", n);
        }, function (e) {
          o("throw", e);
        });
      } catch (e) {
        r("throw", e);
      }
    }
    function r(e, r) {
      switch (e) {
        case "return":
          t.resolve({
            value: r,
            done: !0
          });
          break;
        case "throw":
          t.reject(r);
          break;
        default:
          t.resolve({
            value: r,
            done: !1
          });
      }
      (t = t.next) ? o(t.key, t.arg) : n = null;
    }
    this._invoke = function (e, r) {
      return new Promise(function (i, s) {
        var a = {
          key: e,
          arg: r,
          resolve: i,
          reject: s,
          next: null
        };
        n ? n = n.next = a : (t = n = a, o(e, r));
      });
    }, "function" != typeof e.return && (this.return = void 0);
  }
  function s(e, t) {
    this.v = e, this.k = t;
  }
  function a(e) {
    return new s(e, 0);
  }
  function c() {
    return c = Object.assign ? Object.assign.bind() : function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var o in n) ({}).hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    }, c.apply(null, arguments);
  }
  function l(e, t) {
    if (null == e) return {};
    var n = {};
    for (var o in e) if ({}.hasOwnProperty.call(e, o)) {
      if (t.indexOf(o) >= 0) continue;
      n[o] = e[o];
    }
    return n;
  }
  i.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
    return this;
  }, i.prototype.next = function (e) {
    return this._invoke("next", e);
  }, i.prototype.throw = function (e) {
    return this._invoke("throw", e);
  }, i.prototype.return = function (e) {
    return this._invoke("return", e);
  };
  const d = {
    defaultMerge: Symbol("deepmerge-ts: default merge"),
    skip: Symbol("deepmerge-ts: skip")
  };
  function u(e, t) {
    return t;
  }
  function h(e) {
    return "object" != typeof e || null === e ? 0 : Array.isArray(e) ? 2 : function (e) {
      if (!f.has(Object.prototype.toString.call(e))) return !1;
      const {
        constructor: t
      } = e;
      if (void 0 === t) return !0;
      const n = t.prototype;
      if (null === n || "object" != typeof n || !f.has(Object.prototype.toString.call(n))) return !1;
      if (!n.hasOwnProperty("isPrototypeOf")) return !1;
      return !0;
    }(e) ? 1 : e instanceof Set ? 3 : e instanceof Map ? 4 : 5;
  }
  function p(e) {
    return {
      *[Symbol.iterator]() {
        for (const t of e) for (const e of t) yield e;
      }
    };
  }
  d.defaultMerge;
  const f = new Set(["[object Object]", "[object Module]"]);
  function g(e) {
    return e.at(-1);
  }
  var m = Object.freeze({
    __proto__: null,
    mergeArrays: function (e) {
      return e.flat();
    },
    mergeMaps: function (e) {
      return new Map(p(e));
    },
    mergeOthers: g,
    mergeRecords: function (e, t, n) {
      const o = {};
      for (const s of function (e) {
        const t = new Set();
        for (const n of e) for (const e of [...Object.keys(n), ...Object.getOwnPropertySymbols(n)]) t.add(e);
        return t;
      }(e)) {
        const a = [];
        for (const t of e) i = s, "object" == typeof (r = t) && Object.prototype.propertyIsEnumerable.call(r, i) && a.push(t[s]);
        if (0 === a.length) continue;
        const c = t.metaDataUpdater(n, {
            key: s,
            parents: e
          }),
          l = y(a, t, c);
        l !== d.skip && ("__proto__" === s ? Object.defineProperty(o, s, {
          value: l,
          configurable: !0,
          enumerable: !0,
          writable: !0
        }) : o[s] = l);
      }
      var r, i;
      return o;
    },
    mergeSets: function (e) {
      return new Set(p(e));
    }
  });
  function b(...e) {
    return function (e, t) {
      const n = function (e, t) {
        var n, o;
        return {
          defaultMergeFunctions: m,
          mergeFunctions: c({}, m, Object.fromEntries(Object.entries(e).filter(([e, t]) => Object.hasOwn(m, e)).map(([e, t]) => !1 === t ? [e, g] : [e, t]))),
          metaDataUpdater: null != (n = e.metaDataUpdater) ? n : u,
          deepmerge: t,
          useImplicitDefaultMerging: null != (o = e.enableImplicitDefaultMerging) && o,
          actions: d
        };
      }(e, o);
      function o(...e) {
        return y(e, n, t);
      }
      return o;
    }({})(...e);
  }
  function y(e, t, n) {
    if (0 === e.length) return;
    if (1 === e.length) return w(e, t, n);
    const o = h(e[0]);
    if (0 !== o && 5 !== o) for (let r = 1; r < e.length; r++) if (h(e[r]) !== o) return w(e, t, n);
    switch (o) {
      case 1:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeRecords(e, t, n);
          if (o === d.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeRecords !== t.defaultMergeFunctions.mergeRecords) return t.defaultMergeFunctions.mergeRecords(e, t, n);
          return o;
        }(e, t, n);
      case 2:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeArrays(e, t, n);
          if (o === d.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeArrays !== t.defaultMergeFunctions.mergeArrays) return t.defaultMergeFunctions.mergeArrays(e);
          return o;
        }(e, t, n);
      case 3:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeSets(e, t, n);
          if (o === d.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeSets !== t.defaultMergeFunctions.mergeSets) return t.defaultMergeFunctions.mergeSets(e);
          return o;
        }(e, t, n);
      case 4:
        return function (e, t, n) {
          const o = t.mergeFunctions.mergeMaps(e, t, n);
          if (o === d.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeMaps !== t.defaultMergeFunctions.mergeMaps) return t.defaultMergeFunctions.mergeMaps(e);
          return o;
        }(e, t, n);
      default:
        return w(e, t, n);
    }
  }
  function w(e, t, n) {
    const o = t.mergeFunctions.mergeOthers(e, t, n);
    return o === d.defaultMerge || t.useImplicitDefaultMerging && void 0 === o && t.mergeFunctions.mergeOthers !== t.defaultMergeFunctions.mergeOthers ? t.defaultMergeFunctions.mergeOthers(e) : o;
  }
  function v(e) {
    const t = Object.getOwnPropertyNames(e.constructor.prototype);
    for (let n = 0; n < t.length; n++) {
      const o = t[n],
        r = e[o];
      "constructor" !== o && "function" == typeof r && (e[o] = r.bind(e));
    }
    return e;
  }
  function x(e) {
    const {
      event: t,
      selector: n
    } = e.options.advanceOn || {};
    if (!t) return void 0;
    {
      const r = function (e, t) {
        return n => {
          if (e.isOpen()) {
            const r = e.el && n.currentTarget === e.el;
            (!o(t) && n.currentTarget.matches(t) || r) && e.tour.next();
          }
        };
      }(e, n);
      let i = null;
      if (!o(n) && (i = document.querySelector(n), !i)) return void 0;
      i ? (i.addEventListener(t, r), e.on("destroy", () => i.removeEventListener(t, r))) : (document.body.addEventListener(t, r, !0), e.on("destroy", () => document.body.removeEventListener(t, r, !0)));
    }
  }
  function S(e) {
    return n(e) && "" !== e ? "-" !== e.charAt(e.length - 1) ? `${e}-` : e : "";
  }
  function k(e) {
    return null == e || !e.element || !e.on;
  }
  function E() {
    let e = Date.now();
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
      const n = (e + 16 * Math.random()) % 16 | 0;
      return e = Math.floor(e / 16), ("x" == t ? n : 3 & n | 8).toString(16);
    });
  }
  const _ = Math.min,
    O = Math.max,
    T = Math.round,
    L = Math.floor,
    I = e => ({
      x: e,
      y: e
    }),
    P = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    },
    C = {
      start: "end",
      end: "start"
    };
  function A(e, t, n) {
    return O(e, _(t, n));
  }
  function B(e, t) {
    return "function" == typeof e ? e(t) : e;
  }
  function M(e) {
    return e.split("-")[0];
  }
  function D(e) {
    return e.split("-")[1];
  }
  function F(e) {
    return "x" === e ? "y" : "x";
  }
  function R(e) {
    return "y" === e ? "height" : "width";
  }
  function j(e) {
    return ["top", "bottom"].includes(M(e)) ? "y" : "x";
  }
  function H(e) {
    return F(j(e));
  }
  function q(e) {
    return e.replace(/start|end/g, e => C[e]);
  }
  function N(e) {
    return e.replace(/left|right|bottom|top/g, e => P[e]);
  }
  function W(e) {
    return "number" != typeof e ? function (e) {
      return c({
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }, e);
    }(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function V(e) {
    return c({}, e, {
      top: e.y,
      left: e.x,
      right: e.x + e.width,
      bottom: e.y + e.height
    });
  }
  const z = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"],
    K = ["mainAxis", "crossAxis", "limiter"];
  function U(e, t, n) {
    let {
      reference: o,
      floating: r
    } = e;
    const i = j(t),
      s = H(t),
      a = R(s),
      c = M(t),
      l = "y" === i,
      d = o.x + o.width / 2 - r.width / 2,
      u = o.y + o.height / 2 - r.height / 2,
      h = o[a] / 2 - r[a] / 2;
    let p;
    switch (c) {
      case "top":
        p = {
          x: d,
          y: o.y - r.height
        };
        break;
      case "bottom":
        p = {
          x: d,
          y: o.y + o.height
        };
        break;
      case "right":
        p = {
          x: o.x + o.width,
          y: u
        };
        break;
      case "left":
        p = {
          x: o.x - r.width,
          y: u
        };
        break;
      default:
        p = {
          x: o.x,
          y: o.y
        };
    }
    switch (D(t)) {
      case "start":
        p[s] -= h * (n && l ? -1 : 1);
        break;
      case "end":
        p[s] += h * (n && l ? -1 : 1);
    }
    return p;
  }
  async function X(e, t) {
    var n;
    void 0 === t && (t = {});
    const {
        x: o,
        y: r,
        platform: i,
        rects: s,
        elements: a,
        strategy: l
      } = e,
      {
        boundary: d = "clippingAncestors",
        rootBoundary: u = "viewport",
        elementContext: h = "floating",
        altBoundary: p = !1,
        padding: f = 0
      } = B(t, e),
      g = W(f),
      m = a[p ? "floating" === h ? "reference" : "floating" : h],
      b = V(await i.getClippingRect({
        element: null == (n = await (null == i.isElement ? void 0 : i.isElement(m))) || n ? m : m.contextElement || (await (null == i.getDocumentElement ? void 0 : i.getDocumentElement(a.floating))),
        boundary: d,
        rootBoundary: u,
        strategy: l
      })),
      y = "floating" === h ? c({}, s.floating, {
        x: o,
        y: r
      }) : s.reference,
      w = await (null == i.getOffsetParent ? void 0 : i.getOffsetParent(a.floating)),
      v = (await (null == i.isElement ? void 0 : i.isElement(w))) && (await (null == i.getScale ? void 0 : i.getScale(w))) || {
        x: 1,
        y: 1
      },
      x = V(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: a,
        rect: y,
        offsetParent: w,
        strategy: l
      }) : y);
    return {
      top: (b.top - x.top + g.top) / v.y,
      bottom: (x.bottom - b.bottom + g.bottom) / v.y,
      left: (b.left - x.left + g.left) / v.x,
      right: (x.right - b.right + g.right) / v.x
    };
  }
  function Y(e) {
    return J(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function G(e) {
    var t;
    return (null == e || null == (t = e.ownerDocument) ? void 0 : t.defaultView) || window;
  }
  function Z(e) {
    var t;
    return null == (t = (J(e) ? e.ownerDocument : e.document) || window.document) ? void 0 : t.documentElement;
  }
  function J(e) {
    return e instanceof Node || e instanceof G(e).Node;
  }
  function Q(e) {
    return e instanceof Element || e instanceof G(e).Element;
  }
  function ee(e) {
    return e instanceof HTMLElement || e instanceof G(e).HTMLElement;
  }
  function te(e) {
    return "undefined" != typeof ShadowRoot && (e instanceof ShadowRoot || e instanceof G(e).ShadowRoot);
  }
  function ne(e) {
    const {
      overflow: t,
      overflowX: n,
      overflowY: o,
      display: r
    } = ae(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(r);
  }
  function oe(e) {
    return ["table", "td", "th"].includes(Y(e));
  }
  function re(e) {
    const t = ie(),
      n = ae(e);
    return "none" !== n.transform || "none" !== n.perspective || !!n.containerType && "normal" !== n.containerType || !t && !!n.backdropFilter && "none" !== n.backdropFilter || !t && !!n.filter && "none" !== n.filter || ["transform", "perspective", "filter"].some(e => (n.willChange || "").includes(e)) || ["paint", "layout", "strict", "content"].some(e => (n.contain || "").includes(e));
  }
  function ie() {
    return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
  }
  function se(e) {
    return ["html", "body", "#document"].includes(Y(e));
  }
  function ae(e) {
    return G(e).getComputedStyle(e);
  }
  function ce(e) {
    return Q(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.pageXOffset,
      scrollTop: e.pageYOffset
    };
  }
  function le(e) {
    if ("html" === Y(e)) return e;
    const t = e.assignedSlot || e.parentNode || te(e) && e.host || Z(e);
    return te(t) ? t.host : t;
  }
  function de(e) {
    const t = le(e);
    return se(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ee(t) && ne(t) ? t : de(t);
  }
  function ue(e, t, n) {
    var o;
    void 0 === t && (t = []), void 0 === n && (n = !0);
    const r = de(e),
      i = r === (null == (o = e.ownerDocument) ? void 0 : o.body),
      s = G(r);
    return i ? t.concat(s, s.visualViewport || [], ne(r) ? r : [], s.frameElement && n ? ue(s.frameElement) : []) : t.concat(r, ue(r, [], n));
  }
  function he(e) {
    const t = ae(e);
    let n = parseFloat(t.width) || 0,
      o = parseFloat(t.height) || 0;
    const r = ee(e),
      i = r ? e.offsetWidth : n,
      s = r ? e.offsetHeight : o,
      a = T(n) !== i || T(o) !== s;
    return a && (n = i, o = s), {
      width: n,
      height: o,
      $: a
    };
  }
  function pe(e) {
    return Q(e) ? e : e.contextElement;
  }
  function fe(e) {
    const t = pe(e);
    if (!ee(t)) return I(1);
    const n = t.getBoundingClientRect(),
      {
        width: o,
        height: r,
        $: i
      } = he(t);
    let s = (i ? T(n.width) : n.width) / o,
      a = (i ? T(n.height) : n.height) / r;
    return s && Number.isFinite(s) || (s = 1), a && Number.isFinite(a) || (a = 1), {
      x: s,
      y: a
    };
  }
  const ge = I(0);
  function me(e) {
    const t = G(e);
    return ie() && t.visualViewport ? {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    } : ge;
  }
  function be(e, t, n, o) {
    void 0 === t && (t = !1), void 0 === n && (n = !1);
    const r = e.getBoundingClientRect(),
      i = pe(e);
    let s = I(1);
    t && (o ? Q(o) && (s = fe(o)) : s = fe(e));
    const a = function (e, t, n) {
      return void 0 === t && (t = !1), !(!n || t && n !== G(e)) && t;
    }(i, n, o) ? me(i) : I(0);
    let c = (r.left + a.x) / s.x,
      l = (r.top + a.y) / s.y,
      d = r.width / s.x,
      u = r.height / s.y;
    if (i) {
      const e = G(i),
        t = o && Q(o) ? G(o) : o;
      let n = e,
        r = n.frameElement;
      for (; r && o && t !== n;) {
        const e = fe(r),
          t = r.getBoundingClientRect(),
          o = ae(r),
          i = t.left + (r.clientLeft + parseFloat(o.paddingLeft)) * e.x,
          s = t.top + (r.clientTop + parseFloat(o.paddingTop)) * e.y;
        c *= e.x, l *= e.y, d *= e.x, u *= e.y, c += i, l += s, n = G(r), r = n.frameElement;
      }
    }
    return V({
      width: d,
      height: u,
      x: c,
      y: l
    });
  }
  const ye = [":popover-open", ":modal"];
  function we(e) {
    return ye.some(t => {
      try {
        return e.matches(t);
      } catch (e) {
        return !1;
      }
    });
  }
  function ve(e) {
    return be(Z(e)).left + ce(e).scrollLeft;
  }
  function xe(e, t, n) {
    let o;
    if ("viewport" === t) o = function (e, t) {
      const n = G(e),
        o = Z(e),
        r = n.visualViewport;
      let i = o.clientWidth,
        s = o.clientHeight,
        a = 0,
        c = 0;
      if (r) {
        i = r.width, s = r.height;
        const e = ie();
        (!e || e && "fixed" === t) && (a = r.offsetLeft, c = r.offsetTop);
      }
      return {
        width: i,
        height: s,
        x: a,
        y: c
      };
    }(e, n);else if ("document" === t) o = function (e) {
      const t = Z(e),
        n = ce(e),
        o = e.ownerDocument.body,
        r = O(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth),
        i = O(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
      let s = -n.scrollLeft + ve(e);
      const a = -n.scrollTop;
      return "rtl" === ae(o).direction && (s += O(t.clientWidth, o.clientWidth) - r), {
        width: r,
        height: i,
        x: s,
        y: a
      };
    }(Z(e));else if (Q(t)) o = function (e, t) {
      const n = be(e, !0, "fixed" === t),
        o = n.top + e.clientTop,
        r = n.left + e.clientLeft,
        i = ee(e) ? fe(e) : I(1);
      return {
        width: e.clientWidth * i.x,
        height: e.clientHeight * i.y,
        x: r * i.x,
        y: o * i.y
      };
    }(t, n);else {
      const n = me(e);
      o = c({}, t, {
        x: t.x - n.x,
        y: t.y - n.y
      });
    }
    return V(o);
  }
  function $e(e, t) {
    const n = le(e);
    return !(n === t || !Q(n) || se(n)) && ("fixed" === ae(n).position || $e(n, t));
  }
  function Se(e, t, n) {
    const o = ee(t),
      r = Z(t),
      i = "fixed" === n,
      s = be(e, !0, i, t);
    let a = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const c = I(0);
    if (o || !o && !i) if (("body" !== Y(t) || ne(r)) && (a = ce(t)), o) {
      const e = be(t, !0, i, t);
      c.x = e.x + t.clientLeft, c.y = e.y + t.clientTop;
    } else r && (c.x = ve(r));
    return {
      x: s.left + a.scrollLeft - c.x,
      y: s.top + a.scrollTop - c.y,
      width: s.width,
      height: s.height
    };
  }
  function ke(e) {
    return "static" === ae(e).position;
  }
  function Ee(e, t) {
    return ee(e) && "fixed" !== ae(e).position ? t ? t(e) : e.offsetParent : null;
  }
  function _e(e, t) {
    const n = G(e);
    if (we(e)) return n;
    if (!ee(e)) {
      let t = le(e);
      for (; t && !se(t);) {
        if (Q(t) && !ke(t)) return t;
        t = le(t);
      }
      return n;
    }
    let o = Ee(e, t);
    for (; o && oe(o) && ke(o);) o = Ee(o, t);
    return o && se(o) && ke(o) && !re(o) ? n : o || function (e) {
      let t = le(e);
      for (; ee(t) && !se(t);) {
        if (re(t)) return t;
        t = le(t);
      }
      return null;
    }(e) || n;
  }
  const Oe = {
    convertOffsetParentRelativeRectToViewportRelativeRect: function (e) {
      let {
        elements: t,
        rect: n,
        offsetParent: o,
        strategy: r
      } = e;
      const i = "fixed" === r,
        s = Z(o),
        a = !!t && we(t.floating);
      if (o === s || a && i) return n;
      let c = {
          scrollLeft: 0,
          scrollTop: 0
        },
        l = I(1);
      const d = I(0),
        u = ee(o);
      if ((u || !u && !i) && (("body" !== Y(o) || ne(s)) && (c = ce(o)), ee(o))) {
        const e = be(o);
        l = fe(o), d.x = e.x + o.clientLeft, d.y = e.y + o.clientTop;
      }
      return {
        width: n.width * l.x,
        height: n.height * l.y,
        x: n.x * l.x - c.scrollLeft * l.x + d.x,
        y: n.y * l.y - c.scrollTop * l.y + d.y
      };
    },
    getDocumentElement: Z,
    getClippingRect: function (e) {
      let {
        element: t,
        boundary: n,
        rootBoundary: o,
        strategy: r
      } = e;
      const i = "clippingAncestors" === n ? we(t) ? [] : function (e, t) {
          const n = t.get(e);
          if (n) return n;
          let o = ue(e, [], !1).filter(e => Q(e) && "body" !== Y(e)),
            r = null;
          const i = "fixed" === ae(e).position;
          let s = i ? le(e) : e;
          for (; Q(s) && !se(s);) {
            const t = ae(s),
              n = re(s);
            n || "fixed" !== t.position || (r = null), (i ? !n && !r : !n && "static" === t.position && r && ["absolute", "fixed"].includes(r.position) || ne(s) && !n && $e(e, s)) ? o = o.filter(e => e !== s) : r = t, s = le(s);
          }
          return t.set(e, o), o;
        }(t, this._c) : [].concat(n),
        s = [...i, o],
        a = s[0],
        c = s.reduce((e, n) => {
          const o = xe(t, n, r);
          return e.top = O(o.top, e.top), e.right = _(o.right, e.right), e.bottom = _(o.bottom, e.bottom), e.left = O(o.left, e.left), e;
        }, xe(t, a, r));
      return {
        width: c.right - c.left,
        height: c.bottom - c.top,
        x: c.left,
        y: c.top
      };
    },
    getOffsetParent: _e,
    getElementRects: async function (e) {
      const t = this.getOffsetParent || _e,
        n = this.getDimensions,
        o = await n(e.floating);
      return {
        reference: Se(e.reference, await t(e.floating), e.strategy),
        floating: {
          x: 0,
          y: 0,
          width: o.width,
          height: o.height
        }
      };
    },
    getClientRects: function (e) {
      return Array.from(e.getClientRects());
    },
    getDimensions: function (e) {
      const {
        width: t,
        height: n
      } = he(e);
      return {
        width: t,
        height: n
      };
    },
    getScale: fe,
    isElement: Q,
    isRTL: function (e) {
      return "rtl" === ae(e).direction;
    }
  };
  function Te(e, t, n, o) {
    void 0 === o && (o = {});
    const {
        ancestorScroll: r = !0,
        ancestorResize: i = !0,
        elementResize: s = "function" == typeof ResizeObserver,
        layoutShift: a = "function" == typeof IntersectionObserver,
        animationFrame: l = !1
      } = o,
      d = pe(e),
      u = r || i ? [...(d ? ue(d) : []), ...ue(t)] : [];
    u.forEach(e => {
      r && e.addEventListener("scroll", n, {
        passive: !0
      }), i && e.addEventListener("resize", n);
    });
    const h = d && a ? function (e, t) {
      let n,
        o = null;
      const r = Z(e);
      function i() {
        var e;
        clearTimeout(n), null == (e = o) || e.disconnect(), o = null;
      }
      return function s(a, l) {
        void 0 === a && (a = !1), void 0 === l && (l = 1), i();
        const {
          left: d,
          top: u,
          width: h,
          height: p
        } = e.getBoundingClientRect();
        if (a || t(), !h || !p) return;
        const f = {
          rootMargin: -L(u) + "px " + -L(r.clientWidth - (d + h)) + "px " + -L(r.clientHeight - (u + p)) + "px " + -L(d) + "px",
          threshold: O(0, _(1, l)) || 1
        };
        let g = !0;
        function m(e) {
          const t = e[0].intersectionRatio;
          if (t !== l) {
            if (!g) return s();
            t ? s(!1, t) : n = setTimeout(() => {
              s(!1, 1e-7);
            }, 1e3);
          }
          g = !1;
        }
        try {
          o = new IntersectionObserver(m, c({}, f, {
            root: r.ownerDocument
          }));
        } catch (e) {
          o = new IntersectionObserver(m, f);
        }
        o.observe(e);
      }(!0), i;
    }(d, n) : null;
    let p,
      f = -1,
      g = null;
    s && (g = new ResizeObserver(e => {
      let [o] = e;
      o && o.target === d && g && (g.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
        var e;
        null == (e = g) || e.observe(t);
      })), n();
    }), d && !l && g.observe(d), g.observe(t));
    let m = l ? be(e) : null;
    return l && function t() {
      const o = be(e);
      !m || o.x === m.x && o.y === m.y && o.width === m.width && o.height === m.height || n();
      m = o, p = requestAnimationFrame(t);
    }(), n(), () => {
      var e;
      u.forEach(e => {
        r && e.removeEventListener("scroll", n), i && e.removeEventListener("resize", n);
      }), null == h || h(), null == (e = g) || e.disconnect(), g = null, l && cancelAnimationFrame(p);
    };
  }
  const Le = function (e) {
      return void 0 === e && (e = {}), {
        name: "shift",
        options: e,
        async fn(t) {
          const {
              x: n,
              y: o,
              placement: r
            } = t,
            i = B(e, t),
            {
              mainAxis: s = !0,
              crossAxis: a = !1,
              limiter: d = {
                fn: e => {
                  let {
                    x: t,
                    y: n
                  } = e;
                  return {
                    x: t,
                    y: n
                  };
                }
              }
            } = i,
            u = l(i, K),
            h = {
              x: n,
              y: o
            },
            p = await X(t, u),
            f = j(M(r)),
            g = F(f);
          let m = h[g],
            b = h[f];
          if (s) {
            const e = "y" === g ? "bottom" : "right";
            m = A(m + p["y" === g ? "top" : "left"], m, m - p[e]);
          }
          if (a) {
            const e = "y" === f ? "bottom" : "right";
            b = A(b + p["y" === f ? "top" : "left"], b, b - p[e]);
          }
          const y = d.fn(c({}, t, {
            [g]: m,
            [f]: b
          }));
          return c({}, y, {
            data: {
              x: y.x - n,
              y: y.y - o
            }
          });
        }
      };
    },
    Ie = function (e) {
      return void 0 === e && (e = {}), {
        name: "flip",
        options: e,
        async fn(t) {
          var n, o;
          const {
              placement: r,
              middlewareData: i,
              rects: s,
              initialPlacement: a,
              platform: c,
              elements: d
            } = t,
            u = B(e, t),
            {
              mainAxis: h = !0,
              crossAxis: p = !0,
              fallbackPlacements: f,
              fallbackStrategy: g = "bestFit",
              fallbackAxisSideDirection: m = "none",
              flipAlignment: b = !0
            } = u,
            y = l(u, z);
          if (null != (n = i.arrow) && n.alignmentOffset) return {};
          const w = M(r),
            v = M(a) === a,
            x = await (null == c.isRTL ? void 0 : c.isRTL(d.floating)),
            $ = f || (v || !b ? [N(a)] : function (e) {
              const t = N(e);
              return [q(e), t, q(t)];
            }(a));
          f || "none" === m || $.push(...function (e, t, n, o) {
            const r = D(e);
            let i = function (e, t, n) {
              const o = ["left", "right"],
                r = ["right", "left"],
                i = ["top", "bottom"],
                s = ["bottom", "top"];
              switch (e) {
                case "top":
                case "bottom":
                  return n ? t ? r : o : t ? o : r;
                case "left":
                case "right":
                  return t ? i : s;
                default:
                  return [];
              }
            }(M(e), "start" === n, o);
            return r && (i = i.map(e => e + "-" + r), t && (i = i.concat(i.map(q)))), i;
          }(a, b, m, x));
          const S = [a, ...$],
            k = await X(t, y),
            E = [];
          let _ = (null == (o = i.flip) ? void 0 : o.overflows) || [];
          if (h && E.push(k[w]), p) {
            const e = function (e, t, n) {
              void 0 === n && (n = !1);
              const o = D(e),
                r = H(e),
                i = R(r);
              let s = "x" === r ? o === (n ? "end" : "start") ? "right" : "left" : "start" === o ? "bottom" : "top";
              return t.reference[i] > t.floating[i] && (s = N(s)), [s, N(s)];
            }(r, s, x);
            E.push(k[e[0]], k[e[1]]);
          }
          if (_ = [..._, {
            placement: r,
            overflows: E
          }], !E.every(e => e <= 0)) {
            var O, T;
            const e = ((null == (O = i.flip) ? void 0 : O.index) || 0) + 1,
              t = S[e];
            if (t) return {
              data: {
                index: e,
                overflows: _
              },
              reset: {
                placement: t
              }
            };
            let n = null == (T = _.filter(e => e.overflows[0] <= 0).sort((e, t) => e.overflows[1] - t.overflows[1])[0]) ? void 0 : T.placement;
            if (!n) switch (g) {
              case "bestFit":
                {
                  var L;
                  const e = null == (L = _.map(e => [e.placement, e.overflows.filter(e => e > 0).reduce((e, t) => e + t, 0)]).sort((e, t) => e[1] - t[1])[0]) ? void 0 : L[0];
                  e && (n = e);
                  break;
                }
              case "initialPlacement":
                n = a;
            }
            if (r !== n) return {
              reset: {
                placement: n
              }
            };
          }
          return {};
        }
      };
    },
    Pe = e => ({
      name: "arrow",
      options: e,
      async fn(t) {
        const {
            x: n,
            y: o,
            placement: r,
            rects: i,
            platform: s,
            elements: a,
            middlewareData: l
          } = t,
          {
            element: d,
            padding: u = 0
          } = B(e, t) || {};
        if (null == d) return {};
        const h = W(u),
          p = {
            x: n,
            y: o
          },
          f = H(r),
          g = R(f),
          m = await s.getDimensions(d),
          b = "y" === f,
          y = b ? "top" : "left",
          w = b ? "bottom" : "right",
          v = b ? "clientHeight" : "clientWidth",
          x = i.reference[g] + i.reference[f] - p[f] - i.floating[g],
          $ = p[f] - i.reference[f],
          S = await (null == s.getOffsetParent ? void 0 : s.getOffsetParent(d));
        let k = S ? S[v] : 0;
        k && (await (null == s.isElement ? void 0 : s.isElement(S))) || (k = a.floating[v] || i.floating[g]);
        const E = x / 2 - $ / 2,
          O = k / 2 - m[g] / 2 - 1,
          T = _(h[y], O),
          L = _(h[w], O),
          I = T,
          P = k - m[g] - L,
          C = k / 2 - m[g] / 2 + E,
          M = A(I, C, P),
          F = !l.arrow && null != D(r) && C !== M && i.reference[g] / 2 - (C < I ? T : L) - m[g] / 2 < 0,
          j = F ? C < I ? C - I : C - P : 0;
        return {
          [f]: p[f] + j,
          data: c({
            [f]: M,
            centerOffset: C - M - j
          }, F && {
            alignmentOffset: j
          }),
          reset: F
        };
      }
    }),
    Ce = function (e) {
      return void 0 === e && (e = {}), {
        options: e,
        fn(t) {
          const {
              x: n,
              y: o,
              placement: r,
              rects: i,
              middlewareData: s
            } = t,
            {
              offset: a = 0,
              mainAxis: l = !0,
              crossAxis: d = !0
            } = B(e, t),
            u = {
              x: n,
              y: o
            },
            h = j(r),
            p = F(h);
          let f = u[p],
            g = u[h];
          const m = B(a, t),
            b = "number" == typeof m ? {
              mainAxis: m,
              crossAxis: 0
            } : c({
              mainAxis: 0,
              crossAxis: 0
            }, m);
          if (l) {
            const e = "y" === p ? "height" : "width",
              t = i.reference[p] - i.floating[e] + b.mainAxis,
              n = i.reference[p] + i.reference[e] - b.mainAxis;
            f < t ? f = t : f > n && (f = n);
          }
          if (d) {
            var y, w;
            const e = "y" === p ? "width" : "height",
              t = ["top", "left"].includes(M(r)),
              n = i.reference[h] - i.floating[e] + (t && (null == (y = s.offset) ? void 0 : y[h]) || 0) + (t ? 0 : b.crossAxis),
              o = i.reference[h] + i.reference[e] + (t ? 0 : (null == (w = s.offset) ? void 0 : w[h]) || 0) - (t ? b.crossAxis : 0);
            g < n ? g = n : g > o && (g = o);
          }
          return {
            [p]: f,
            [h]: g
          };
        }
      };
    },
    Ae = (e, t, n) => {
      const o = new Map(),
        r = c({
          platform: Oe
        }, n),
        i = c({}, r.platform, {
          _c: o
        });
      return (async (e, t, n) => {
        const {
            placement: o = "bottom",
            strategy: r = "absolute",
            middleware: i = [],
            platform: s
          } = n,
          a = i.filter(Boolean),
          l = await (null == s.isRTL ? void 0 : s.isRTL(t));
        let d = await s.getElementRects({
            reference: e,
            floating: t,
            strategy: r
          }),
          {
            x: u,
            y: h
          } = U(d, o, l),
          p = o,
          f = {},
          g = 0;
        for (let n = 0; n < a.length; n++) {
          const {
              name: i,
              fn: m
            } = a[n],
            {
              x: b,
              y: y,
              data: w,
              reset: v
            } = await m({
              x: u,
              y: h,
              initialPlacement: o,
              placement: p,
              strategy: r,
              middlewareData: f,
              rects: d,
              platform: s,
              elements: {
                reference: e,
                floating: t
              }
            });
          u = null != b ? b : u, h = null != y ? y : h, f = c({}, f, {
            [i]: c({}, f[i], w)
          }), v && g <= 50 && (g++, "object" == typeof v && (v.placement && (p = v.placement), v.rects && (d = !0 === v.rects ? await s.getElementRects({
            reference: e,
            floating: t,
            strategy: r
          }) : v.rects), ({
            x: u,
            y: h
          } = U(d, p, l))), n = -1);
        }
        return {
          x: u,
          y: h,
          placement: p,
          strategy: r,
          middlewareData: f
        };
      })(e, t, c({}, r, {
        platform: i
      }));
    };
  function Be(t) {
    t.cleanup && t.cleanup();
    const n = t._getResolvedAttachToOptions();
    let o = n.element;
    const r = function (e, t) {
        const n = {
            strategy: "absolute",
            middleware: []
          },
          o = function (e) {
            if (e.options.arrow && e.el) return e.el.querySelector(".shepherd-arrow");
            return !1;
          }(t),
          r = k(e);
        r || (n.middleware.push(Ie(), Le({
          limiter: Ce(),
          crossAxis: !0
        })), o && n.middleware.push(Pe({
          element: o
        })), n.placement = e.on);
        return b(t.options.floatingUIOptions || {}, n);
      }(n, t),
      i = k(n);
    if (i) {
      o = document.body;
      t.shepherdElementComponent.getElement().classList.add("shepherd-centered");
    }
    return t.cleanup = Te(o, t.el, () => {
      t.el ? function (t, n, o, r) {
        Ae(t, n.el, o).then(function (t, n) {
          return ({
            x: o,
            y: r,
            placement: i,
            middlewareData: s
          }) => t.el ? (n ? Object.assign(t.el.style, {
            position: "fixed",
            left: "50%",
            top: "50%",
            transform: "translate(-50%, -50%)"
          }) : Object.assign(t.el.style, {
            position: "absolute",
            left: `${o}px`,
            top: `${r}px`
          }), t.el.dataset.popperPlacement = i, function (t, n) {
            const o = t.querySelector(".shepherd-arrow");
            if (e(o) && n.arrow) {
              const {
                x: e,
                y: t
              } = n.arrow;
              Object.assign(o.style, {
                left: null != e ? `${e}px` : "",
                top: null != t ? `${t}px` : ""
              });
            }
          }(t.el, s), t) : t;
        }(n, r)).then(e => new Promise(t => {
          setTimeout(() => t(e), 300);
        })).then(e => {
          null != e && e.el && e.el.focus({
            preventScroll: !0
          });
        });
      }(o, t, r, i) : null == t.cleanup || t.cleanup();
    }), t.target = n.element, r;
  }
  function Me() {}
  function De(e, t) {
    for (const n in t) e[n] = t[n];
    return e;
  }
  function Fe(e) {
    return e();
  }
  function Re() {
    return Object.create(null);
  }
  function je(e) {
    e.forEach(Fe);
  }
  function He(e) {
    return "function" == typeof e;
  }
  function qe(e, t) {
    return e != e ? t == t : e !== t || e && "object" == typeof e || "function" == typeof e;
  }
  function Ne(e, t) {
    e.appendChild(t);
  }
  function We(e, t, n) {
    e.insertBefore(t, n || null);
  }
  function Ve(e) {
    e.parentNode && e.parentNode.removeChild(e);
  }
  function ze(e) {
    return document.createElement(e);
  }
  function Ke(e) {
    return document.createElementNS("http://www.w3.org/2000/svg", e);
  }
  function Ue(e) {
    return document.createTextNode(e);
  }
  function Xe() {
    return Ue(" ");
  }
  function Ye(e, t, n, o) {
    return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);
  }
  function Ge(e, t, n) {
    null == n ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
  }
  const Ze = ["width", "height"];
  function Je(e, t) {
    const n = Object.getOwnPropertyDescriptors(e.__proto__);
    for (const o in t) null == t[o] ? e.removeAttribute(o) : "style" === o ? e.style.cssText = t[o] : "__value" === o ? e.value = e[o] = t[o] : n[o] && n[o].set && -1 === Ze.indexOf(o) ? e[o] = t[o] : Ge(e, o, t[o]);
  }
  function Qe(e, t, n) {
    e.classList.toggle(t, !!n);
  }
  let et;
  function tt(e) {
    et = e;
  }
  function nt() {
    if (!et) throw new Error("Function called outside component initialization");
    return et;
  }
  function ot(e) {
    nt().$$.after_update.push(e);
  }
  const rt = [],
    it = [];
  let st = [];
  const at = [],
    ct = Promise.resolve();
  let lt = !1;
  function dt(e) {
    st.push(e);
  }
  const ut = new Set();
  let ht = 0;
  function pt() {
    if (0 !== ht) return;
    const e = et;
    do {
      try {
        for (; ht < rt.length;) {
          const e = rt[ht];
          ht++, tt(e), ft(e.$$);
        }
      } catch (e) {
        throw rt.length = 0, ht = 0, e;
      }
      for (tt(null), rt.length = 0, ht = 0; it.length;) it.pop()();
      for (let e = 0; e < st.length; e += 1) {
        const t = st[e];
        ut.has(t) || (ut.add(t), t());
      }
      st.length = 0;
    } while (rt.length);
    for (; at.length;) at.pop()();
    lt = !1, ut.clear(), tt(e);
  }
  function ft(e) {
    if (null !== e.fragment) {
      e.update(), je(e.before_update);
      const t = e.dirty;
      e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(dt);
    }
  }
  const gt = new Set();
  let mt;
  function bt() {
    mt = {
      r: 0,
      c: [],
      p: mt
    };
  }
  function yt() {
    mt.r || je(mt.c), mt = mt.p;
  }
  function wt(e, t) {
    e && e.i && (gt.delete(e), e.i(t));
  }
  function vt(e, t, n, o) {
    if (e && e.o) {
      if (gt.has(e)) return;
      gt.add(e), mt.c.push(() => {
        gt.delete(e), o && (n && e.d(1), o());
      }), e.o(t);
    } else o && o();
  }
  function xt(e) {
    return void 0 !== (null == e ? void 0 : e.length) ? e : Array.from(e);
  }
  function $t(e) {
    e && e.c();
  }
  function St(e, t, n) {
    const {
      fragment: o,
      after_update: r
    } = e.$$;
    o && o.m(t, n), dt(() => {
      const t = e.$$.on_mount.map(Fe).filter(He);
      e.$$.on_destroy ? e.$$.on_destroy.push(...t) : je(t), e.$$.on_mount = [];
    }), r.forEach(dt);
  }
  function kt(e, t) {
    const n = e.$$;
    null !== n.fragment && (!function (e) {
      const t = [],
        n = [];
      st.forEach(o => -1 === e.indexOf(o) ? t.push(o) : n.push(o)), n.forEach(e => e()), st = t;
    }(n.after_update), je(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
  }
  function Et(e, t) {
    -1 === e.$$.dirty[0] && (rt.push(e), lt || (lt = !0, ct.then(pt)), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
  }
  function _t(e, t, n, o, r, i, s = null, a = [-1]) {
    const c = et;
    tt(e);
    const l = e.$$ = {
      fragment: null,
      ctx: [],
      props: i,
      update: Me,
      not_equal: r,
      bound: Re(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(t.context || (c ? c.$$.context : [])),
      callbacks: Re(),
      dirty: a,
      skip_bound: !1,
      root: t.target || c.$$.root
    };
    s && s(l.root);
    let d = !1;
    if (l.ctx = n ? n(e, t.props || {}, (t, n, ...o) => {
      const i = o.length ? o[0] : n;
      return l.ctx && r(l.ctx[t], l.ctx[t] = i) && (!l.skip_bound && l.bound[t] && l.bound[t](i), d && Et(e, t)), n;
    }) : [], l.update(), d = !0, je(l.before_update), l.fragment = !!o && o(l.ctx), t.target) {
      if (t.hydrate) {
        const e = function (e) {
          return Array.from(e.childNodes);
        }(t.target);
        l.fragment && l.fragment.l(e), e.forEach(Ve);
      } else l.fragment && l.fragment.c();
      t.intro && wt(e.$$.fragment), St(e, t.target, t.anchor), pt();
    }
    tt(c);
  }
  class Ot {
    constructor() {
      this.$$ = void 0, this.$$set = void 0;
    }
    $destroy() {
      kt(this, 1), this.$destroy = Me;
    }
    $on(e, t) {
      if (!He(t)) return Me;
      const n = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
      return n.push(t), () => {
        const e = n.indexOf(t);
        -1 !== e && n.splice(e, 1);
      };
    }
    $set(e) {
      var t;
      this.$$set && (t = e, 0 !== Object.keys(t).length) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
    }
  }
  function Tt(e) {
    let t, n, o, r, i;
    return {
      c() {
        t = ze("button"), Ge(t, "aria-label", n = e[3] ? e[3] : null), Ge(t, "class", o = `${e[1] || ""} shepherd-button ${e[4] ? "shepherd-button-secondary" : ""}`), t.disabled = e[2], Ge(t, "tabindex", "0"), Ge(t, "type", "button");
      },
      m(n, o) {
        We(n, t, o), t.innerHTML = e[5], r || (i = Ye(t, "click", function () {
          He(e[0]) && e[0].apply(this, arguments);
        }), r = !0);
      },
      p(r, [i]) {
        e = r, 32 & i && (t.innerHTML = e[5]), 8 & i && n !== (n = e[3] ? e[3] : null) && Ge(t, "aria-label", n), 18 & i && o !== (o = `${e[1] || ""} shepherd-button ${e[4] ? "shepherd-button-secondary" : ""}`) && Ge(t, "class", o), 4 & i && (t.disabled = e[2]);
      },
      i: Me,
      o: Me,
      d(e) {
        e && Ve(t), r = !1, i();
      }
    };
  }
  function Lt(e, n, o) {
    let r,
      i,
      s,
      a,
      c,
      l,
      {
        config: d,
        step: u
      } = n;
    function h(e) {
      return t(e) ? e.call(u) : e;
    }
    return e.$$set = e => {
      "config" in e && o(6, d = e.config), "step" in e && o(7, u = e.step);
    }, e.$$.update = () => {
      192 & e.$$.dirty && (o(0, r = d.action ? d.action.bind(u.tour) : null), o(1, i = d.classes), o(2, s = !!d.disabled && h(d.disabled)), o(3, a = d.label ? h(d.label) : null), o(4, c = d.secondary), o(5, l = d.text ? h(d.text) : null));
    }, [r, i, s, a, c, l, d, u];
  }
  "undefined" != typeof window && (window.__svelte || (window.__svelte = {
    v: new Set()
  })).v.add("4");
  class It extends Ot {
    constructor(e) {
      super(), _t(this, e, Lt, Tt, qe, {
        config: 6,
        step: 7
      });
    }
  }
  function Pt(e, t, n) {
    const o = e.slice();
    return o[2] = t[n], o;
  }
  function Ct(e) {
    let t,
      n,
      o = xt(e[1]),
      r = [];
    for (let t = 0; t < o.length; t += 1) r[t] = At(Pt(e, o, t));
    const i = e => vt(r[e], 1, 1, () => {
      r[e] = null;
    });
    return {
      c() {
        for (let e = 0; e < r.length; e += 1) r[e].c();
        t = Ue("");
      },
      m(e, o) {
        for (let t = 0; t < r.length; t += 1) r[t] && r[t].m(e, o);
        We(e, t, o), n = !0;
      },
      p(e, n) {
        if (3 & n) {
          let s;
          for (o = xt(e[1]), s = 0; s < o.length; s += 1) {
            const i = Pt(e, o, s);
            r[s] ? (r[s].p(i, n), wt(r[s], 1)) : (r[s] = At(i), r[s].c(), wt(r[s], 1), r[s].m(t.parentNode, t));
          }
          for (bt(), s = o.length; s < r.length; s += 1) i(s);
          yt();
        }
      },
      i(e) {
        if (!n) {
          for (let e = 0; e < o.length; e += 1) wt(r[e]);
          n = !0;
        }
      },
      o(e) {
        r = r.filter(Boolean);
        for (let e = 0; e < r.length; e += 1) vt(r[e]);
        n = !1;
      },
      d(e) {
        e && Ve(t), function (e, t) {
          for (let n = 0; n < e.length; n += 1) e[n] && e[n].d(t);
        }(r, e);
      }
    };
  }
  function At(e) {
    let t, n;
    return t = new It({
      props: {
        config: e[2],
        step: e[0]
      }
    }), {
      c() {
        $t(t.$$.fragment);
      },
      m(e, o) {
        St(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        2 & n && (o.config = e[2]), 1 & n && (o.step = e[0]), t.$set(o);
      },
      i(e) {
        n || (wt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        vt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        kt(t, e);
      }
    };
  }
  function Bt(e) {
    let t,
      n,
      o = e[1] && Ct(e);
    return {
      c() {
        t = ze("footer"), o && o.c(), Ge(t, "class", "shepherd-footer");
      },
      m(e, r) {
        We(e, t, r), o && o.m(t, null), n = !0;
      },
      p(e, [n]) {
        e[1] ? o ? (o.p(e, n), 2 & n && wt(o, 1)) : (o = Ct(e), o.c(), wt(o, 1), o.m(t, null)) : o && (bt(), vt(o, 1, 1, () => {
          o = null;
        }), yt());
      },
      i(e) {
        n || (wt(o), n = !0);
      },
      o(e) {
        vt(o), n = !1;
      },
      d(e) {
        e && Ve(t), o && o.d();
      }
    };
  }
  function Mt(e, t, n) {
    let o,
      {
        step: r
      } = t;
    return e.$$set = e => {
      "step" in e && n(0, r = e.step);
    }, e.$$.update = () => {
      1 & e.$$.dirty && n(1, o = r.options.buttons);
    }, [r, o];
  }
  class Dt extends Ot {
    constructor(e) {
      super(), _t(this, e, Mt, Bt, qe, {
        step: 0
      });
    }
  }
  function Ft(e) {
    let t, n, o, r, i;
    return {
      c() {
        t = ze("button"), n = ze("span"), n.textContent = "Ã—", Ge(n, "aria-hidden", "true"), Ge(t, "aria-label", o = e[0].label ? e[0].label : "Close Tour"), Ge(t, "class", "shepherd-cancel-icon"), Ge(t, "type", "button");
      },
      m(o, s) {
        We(o, t, s), Ne(t, n), r || (i = Ye(t, "click", e[1]), r = !0);
      },
      p(e, [n]) {
        1 & n && o !== (o = e[0].label ? e[0].label : "Close Tour") && Ge(t, "aria-label", o);
      },
      i: Me,
      o: Me,
      d(e) {
        e && Ve(t), r = !1, i();
      }
    };
  }
  function Rt(e, t, n) {
    let {
      cancelIcon: o,
      step: r
    } = t;
    return e.$$set = e => {
      "cancelIcon" in e && n(0, o = e.cancelIcon), "step" in e && n(2, r = e.step);
    }, [o, e => {
      e.preventDefault(), r.cancel();
    }, r];
  }
  class jt extends Ot {
    constructor(e) {
      super(), _t(this, e, Rt, Ft, qe, {
        cancelIcon: 0,
        step: 2
      });
    }
  }
  function Ht(e) {
    let t;
    return {
      c() {
        t = ze("h3"), Ge(t, "id", e[1]), Ge(t, "class", "shepherd-title");
      },
      m(n, o) {
        We(n, t, o), e[3](t);
      },
      p(e, [n]) {
        2 & n && Ge(t, "id", e[1]);
      },
      i: Me,
      o: Me,
      d(n) {
        n && Ve(t), e[3](null);
      }
    };
  }
  function qt(e, n, o) {
    let {
      labelId: r,
      element: i,
      title: s
    } = n;
    return ot(() => {
      t(s) && o(2, s = s()), o(0, i.innerHTML = s, i);
    }), e.$$set = e => {
      "labelId" in e && o(1, r = e.labelId), "element" in e && o(0, i = e.element), "title" in e && o(2, s = e.title);
    }, [i, r, s, function (e) {
      it[e ? "unshift" : "push"](() => {
        i = e, o(0, i);
      });
    }];
  }
  class Nt extends Ot {
    constructor(e) {
      super(), _t(this, e, qt, Ht, qe, {
        labelId: 1,
        element: 0,
        title: 2
      });
    }
  }
  function Wt(e) {
    let t, n;
    return t = new Nt({
      props: {
        labelId: e[0],
        title: e[2]
      }
    }), {
      c() {
        $t(t.$$.fragment);
      },
      m(e, o) {
        St(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        1 & n && (o.labelId = e[0]), 4 & n && (o.title = e[2]), t.$set(o);
      },
      i(e) {
        n || (wt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        vt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        kt(t, e);
      }
    };
  }
  function Vt(e) {
    let t, n;
    return t = new jt({
      props: {
        cancelIcon: e[3],
        step: e[1]
      }
    }), {
      c() {
        $t(t.$$.fragment);
      },
      m(e, o) {
        St(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        8 & n && (o.cancelIcon = e[3]), 2 & n && (o.step = e[1]), t.$set(o);
      },
      i(e) {
        n || (wt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        vt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        kt(t, e);
      }
    };
  }
  function zt(e) {
    let t,
      n,
      o,
      r = e[2] && Wt(e),
      i = e[3] && e[3].enabled && Vt(e);
    return {
      c() {
        t = ze("header"), r && r.c(), n = Xe(), i && i.c(), Ge(t, "class", "shepherd-header");
      },
      m(e, s) {
        We(e, t, s), r && r.m(t, null), Ne(t, n), i && i.m(t, null), o = !0;
      },
      p(e, [o]) {
        e[2] ? r ? (r.p(e, o), 4 & o && wt(r, 1)) : (r = Wt(e), r.c(), wt(r, 1), r.m(t, n)) : r && (bt(), vt(r, 1, 1, () => {
          r = null;
        }), yt()), e[3] && e[3].enabled ? i ? (i.p(e, o), 8 & o && wt(i, 1)) : (i = Vt(e), i.c(), wt(i, 1), i.m(t, null)) : i && (bt(), vt(i, 1, 1, () => {
          i = null;
        }), yt());
      },
      i(e) {
        o || (wt(r), wt(i), o = !0);
      },
      o(e) {
        vt(r), vt(i), o = !1;
      },
      d(e) {
        e && Ve(t), r && r.d(), i && i.d();
      }
    };
  }
  function Kt(e, t, n) {
    let o,
      r,
      {
        labelId: i,
        step: s
      } = t;
    return e.$$set = e => {
      "labelId" in e && n(0, i = e.labelId), "step" in e && n(1, s = e.step);
    }, e.$$.update = () => {
      2 & e.$$.dirty && (n(2, o = s.options.title), n(3, r = s.options.cancelIcon));
    }, [i, s, o, r];
  }
  class Ut extends Ot {
    constructor(e) {
      super(), _t(this, e, Kt, zt, qe, {
        labelId: 0,
        step: 1
      });
    }
  }
  function Xt(e) {
    let t;
    return {
      c() {
        t = ze("div"), Ge(t, "class", "shepherd-text"), Ge(t, "id", e[1]);
      },
      m(n, o) {
        We(n, t, o), e[3](t);
      },
      p(e, [n]) {
        2 & n && Ge(t, "id", e[1]);
      },
      i: Me,
      o: Me,
      d(n) {
        n && Ve(t), e[3](null);
      }
    };
  }
  function Yt(n, o, r) {
    let {
      descriptionId: i,
      element: s,
      step: a
    } = o;
    return ot(() => {
      let {
        text: n
      } = a.options;
      t(n) && (n = n.call(a)), e(n) ? s.appendChild(n) : r(0, s.innerHTML = n, s);
    }), n.$$set = e => {
      "descriptionId" in e && r(1, i = e.descriptionId), "element" in e && r(0, s = e.element), "step" in e && r(2, a = e.step);
    }, [s, i, a, function (e) {
      it[e ? "unshift" : "push"](() => {
        s = e, r(0, s);
      });
    }];
  }
  class Gt extends Ot {
    constructor(e) {
      super(), _t(this, e, Yt, Xt, qe, {
        descriptionId: 1,
        element: 0,
        step: 2
      });
    }
  }
  function Zt(e) {
    let t, n;
    return t = new Ut({
      props: {
        labelId: e[1],
        step: e[2]
      }
    }), {
      c() {
        $t(t.$$.fragment);
      },
      m(e, o) {
        St(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        2 & n && (o.labelId = e[1]), 4 & n && (o.step = e[2]), t.$set(o);
      },
      i(e) {
        n || (wt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        vt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        kt(t, e);
      }
    };
  }
  function Jt(e) {
    let t, n;
    return t = new Gt({
      props: {
        descriptionId: e[0],
        step: e[2]
      }
    }), {
      c() {
        $t(t.$$.fragment);
      },
      m(e, o) {
        St(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        1 & n && (o.descriptionId = e[0]), 4 & n && (o.step = e[2]), t.$set(o);
      },
      i(e) {
        n || (wt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        vt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        kt(t, e);
      }
    };
  }
  function Qt(e) {
    let t, n;
    return t = new Dt({
      props: {
        step: e[2]
      }
    }), {
      c() {
        $t(t.$$.fragment);
      },
      m(e, o) {
        St(t, e, o), n = !0;
      },
      p(e, n) {
        const o = {};
        4 & n && (o.step = e[2]), t.$set(o);
      },
      i(e) {
        n || (wt(t.$$.fragment, e), n = !0);
      },
      o(e) {
        vt(t.$$.fragment, e), n = !1;
      },
      d(e) {
        kt(t, e);
      }
    };
  }
  function en(e) {
    let t,
      n,
      r,
      i,
      s = !o(e[2].options.title) || e[2].options.cancelIcon && e[2].options.cancelIcon.enabled,
      a = !o(e[2].options.text),
      c = Array.isArray(e[2].options.buttons) && e[2].options.buttons.length,
      l = s && Zt(e),
      d = a && Jt(e),
      u = c && Qt(e);
    return {
      c() {
        t = ze("div"), l && l.c(), n = Xe(), d && d.c(), r = Xe(), u && u.c(), Ge(t, "class", "shepherd-content");
      },
      m(e, o) {
        We(e, t, o), l && l.m(t, null), Ne(t, n), d && d.m(t, null), Ne(t, r), u && u.m(t, null), i = !0;
      },
      p(e, [i]) {
        4 & i && (s = !o(e[2].options.title) || e[2].options.cancelIcon && e[2].options.cancelIcon.enabled), s ? l ? (l.p(e, i), 4 & i && wt(l, 1)) : (l = Zt(e), l.c(), wt(l, 1), l.m(t, n)) : l && (bt(), vt(l, 1, 1, () => {
          l = null;
        }), yt()), 4 & i && (a = !o(e[2].options.text)), a ? d ? (d.p(e, i), 4 & i && wt(d, 1)) : (d = Jt(e), d.c(), wt(d, 1), d.m(t, r)) : d && (bt(), vt(d, 1, 1, () => {
          d = null;
        }), yt()), 4 & i && (c = Array.isArray(e[2].options.buttons) && e[2].options.buttons.length), c ? u ? (u.p(e, i), 4 & i && wt(u, 1)) : (u = Qt(e), u.c(), wt(u, 1), u.m(t, null)) : u && (bt(), vt(u, 1, 1, () => {
          u = null;
        }), yt());
      },
      i(e) {
        i || (wt(l), wt(d), wt(u), i = !0);
      },
      o(e) {
        vt(l), vt(d), vt(u), i = !1;
      },
      d(e) {
        e && Ve(t), l && l.d(), d && d.d(), u && u.d();
      }
    };
  }
  function tn(e, t, n) {
    let {
      descriptionId: o,
      labelId: r,
      step: i
    } = t;
    return e.$$set = e => {
      "descriptionId" in e && n(0, o = e.descriptionId), "labelId" in e && n(1, r = e.labelId), "step" in e && n(2, i = e.step);
    }, [o, r, i];
  }
  class nn extends Ot {
    constructor(e) {
      super(), _t(this, e, tn, en, qe, {
        descriptionId: 0,
        labelId: 1,
        step: 2
      });
    }
  }
  function on(e) {
    let t;
    return {
      c() {
        t = ze("div"), Ge(t, "class", "shepherd-arrow"), Ge(t, "data-popper-arrow", "");
      },
      m(e, n) {
        We(e, t, n);
      },
      d(e) {
        e && Ve(t);
      }
    };
  }
  function rn(e) {
    let t,
      n,
      r,
      i,
      s,
      a,
      c,
      l,
      d = e[4].options.arrow && e[4].options.attachTo && e[4].options.attachTo.element && e[4].options.attachTo.on && on();
    r = new nn({
      props: {
        descriptionId: e[2],
        labelId: e[3],
        step: e[4]
      }
    });
    let u = [{
        "aria-describedby": i = o(e[4].options.text) ? null : e[2]
      }, {
        "aria-labelledby": s = e[4].options.title ? e[3] : null
      }, e[1], {
        role: "dialog"
      }, {
        tabindex: "0"
      }],
      h = {};
    for (let e = 0; e < u.length; e += 1) h = De(h, u[e]);
    return {
      c() {
        t = ze("div"), d && d.c(), n = Xe(), $t(r.$$.fragment), Je(t, h), Qe(t, "shepherd-has-cancel-icon", e[5]), Qe(t, "shepherd-has-title", e[6]), Qe(t, "shepherd-element", !0);
      },
      m(o, i) {
        We(o, t, i), d && d.m(t, null), Ne(t, n), St(r, t, null), e[13](t), a = !0, c || (l = Ye(t, "keydown", e[7]), c = !0);
      },
      p(e, [c]) {
        e[4].options.arrow && e[4].options.attachTo && e[4].options.attachTo.element && e[4].options.attachTo.on ? d || (d = on(), d.c(), d.m(t, n)) : d && (d.d(1), d = null);
        const l = {};
        4 & c && (l.descriptionId = e[2]), 8 & c && (l.labelId = e[3]), 16 & c && (l.step = e[4]), r.$set(l), Je(t, h = function (e, t) {
          const n = {},
            o = {},
            r = {
              $$scope: 1
            };
          let i = e.length;
          for (; i--;) {
            const s = e[i],
              a = t[i];
            if (a) {
              for (const e in s) e in a || (o[e] = 1);
              for (const e in a) r[e] || (n[e] = a[e], r[e] = 1);
              e[i] = a;
            } else for (const e in s) r[e] = 1;
          }
          for (const e in o) e in n || (n[e] = void 0);
          return n;
        }(u, [(!a || 20 & c && i !== (i = o(e[4].options.text) ? null : e[2])) && {
          "aria-describedby": i
        }, (!a || 24 & c && s !== (s = e[4].options.title ? e[3] : null)) && {
          "aria-labelledby": s
        }, 2 & c && e[1], {
          role: "dialog"
        }, {
          tabindex: "0"
        }])), Qe(t, "shepherd-has-cancel-icon", e[5]), Qe(t, "shepherd-has-title", e[6]), Qe(t, "shepherd-element", !0);
      },
      i(e) {
        a || (wt(r.$$.fragment, e), a = !0);
      },
      o(e) {
        vt(r.$$.fragment, e), a = !1;
      },
      d(n) {
        n && Ve(t), d && d.d(), kt(r), e[13](null), c = !1, l();
      }
    };
  }
  function sn(e) {
    return e.split(" ").filter(e => !!e.length);
  }
  function an(e, t, o) {
    let r,
      i,
      s,
      {
        classPrefix: a,
        element: c,
        descriptionId: l,
        firstFocusableElement: d,
        focusableElements: u,
        labelId: h,
        lastFocusableElement: p,
        step: f,
        dataStepId: g
      } = t;
    var m;
    m = () => {
      o(1, g = {
        [`data-${a}shepherd-step-id`]: f.id
      }), o(9, u = c.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]')), o(8, d = u[0]), o(10, p = u[u.length - 1]);
    }, nt().$$.on_mount.push(m), ot(() => {
      s !== f.options.classes && (function (e) {
        if (n(e)) {
          const t = sn(e);
          t.length && c.classList.remove(...t);
        }
      }(s), s = f.options.classes, function (e) {
        if (n(e)) {
          const t = sn(e);
          t.length && c.classList.add(...t);
        }
      }(s));
    });
    return e.$$set = e => {
      "classPrefix" in e && o(11, a = e.classPrefix), "element" in e && o(0, c = e.element), "descriptionId" in e && o(2, l = e.descriptionId), "firstFocusableElement" in e && o(8, d = e.firstFocusableElement), "focusableElements" in e && o(9, u = e.focusableElements), "labelId" in e && o(3, h = e.labelId), "lastFocusableElement" in e && o(10, p = e.lastFocusableElement), "step" in e && o(4, f = e.step), "dataStepId" in e && o(1, g = e.dataStepId);
    }, e.$$.update = () => {
      16 & e.$$.dirty && (o(5, r = f.options && f.options.cancelIcon && f.options.cancelIcon.enabled), o(6, i = f.options && f.options.title));
    }, [c, g, l, h, f, r, i, e => {
      const {
        tour: t
      } = f;
      switch (e.keyCode) {
        case 9:
          if (0 === u.length) {
            e.preventDefault();
            break;
          }
          e.shiftKey ? (document.activeElement === d || document.activeElement.classList.contains("shepherd-element")) && (e.preventDefault(), p.focus()) : document.activeElement === p && (e.preventDefault(), d.focus());
          break;
        case 27:
          t.options.exitOnEsc && (e.preventDefault(), e.stopPropagation(), f.cancel());
          break;
        case 37:
          t.options.keyboardNavigation && (e.preventDefault(), e.stopPropagation(), t.back());
          break;
        case 39:
          t.options.keyboardNavigation && (e.preventDefault(), e.stopPropagation(), t.next());
      }
    }, d, u, p, a, () => c, function (e) {
      it[e ? "unshift" : "push"](() => {
        c = e, o(0, c);
      });
    }];
  }
  class cn extends Ot {
    constructor(e) {
      super(), _t(this, e, an, rn, qe, {
        classPrefix: 11,
        element: 0,
        descriptionId: 2,
        firstFocusableElement: 8,
        focusableElements: 9,
        labelId: 3,
        lastFocusableElement: 10,
        step: 4,
        dataStepId: 1,
        getElement: 12
      });
    }
    get getElement() {
      return this.$$.ctx[12];
    }
  }
  class ln extends r {
    constructor(e, t = {}) {
      return super(), this._resolvedAttachTo = void 0, this.classPrefix = void 0, this.el = void 0, this.target = void 0, this.tour = void 0, this.tour = e, this.classPrefix = this.tour.options ? S(this.tour.options.classPrefix) : "", this.styles = e.styles, this._resolvedAttachTo = null, v(this), this._setOptions(t), this;
    }
    cancel() {
      this.tour.cancel(), this.trigger("cancel");
    }
    complete() {
      this.tour.complete(), this.trigger("complete");
    }
    destroy() {
      var t;
      (t = this).cleanup && t.cleanup(), t.cleanup = null, e(this.el) && (this.el.remove(), this.el = null), this._updateStepTargetOnHide(), this.trigger("destroy");
    }
    getTour() {
      return this.tour;
    }
    hide() {
      var e;
      null == (e = this.tour.modal) || e.hide(), this.trigger("before-hide"), this.el && (this.el.hidden = !0), this._updateStepTargetOnHide(), this.trigger("hide");
    }
    _resolveAttachToOptions() {
      return this._resolvedAttachTo = function (e) {
        const o = e.options.attachTo || {},
          r = Object.assign({}, o);
        if (t(r.element) && (r.element = r.element.call(e)), n(r.element)) {
          try {
            r.element = document.querySelector(r.element);
          } catch (e) {}
          r.element || void 0;
        }
        return r;
      }(this), this._resolvedAttachTo;
    }
    _getResolvedAttachToOptions() {
      return null === this._resolvedAttachTo ? this._resolveAttachToOptions() : this._resolvedAttachTo;
    }
    isOpen() {
      return Boolean(this.el && !this.el.hidden);
    }
    show() {
      return t(this.options.beforeShowPromise) ? Promise.resolve(this.options.beforeShowPromise()).then(() => this._show()) : Promise.resolve(this._show());
    }
    updateStepOptions(e) {
      Object.assign(this.options, e), this.shepherdElementComponent && this.shepherdElementComponent.$set({
        step: this
      });
    }
    getElement() {
      return this.el;
    }
    getTarget() {
      return this.target;
    }
    _createTooltipContent() {
      const e = `${this.id}-description`,
        t = `${this.id}-label`;
      return this.shepherdElementComponent = new cn({
        target: this.tour.options.stepsContainer || document.body,
        props: {
          classPrefix: this.classPrefix,
          descriptionId: e,
          labelId: t,
          step: this,
          styles: this.styles
        }
      }), this.shepherdElementComponent.getElement();
    }
    _scrollTo(e) {
      const {
        element: n
      } = this._getResolvedAttachToOptions();
      t(this.options.scrollToHandler) ? this.options.scrollToHandler(n) : n instanceof Element && "function" == typeof n.scrollIntoView && n.scrollIntoView(e);
    }
    _getClassOptions(e) {
      const t = this.tour && this.tour.options && this.tour.options.defaultStepOptions,
        n = e.classes ? e.classes : "",
        o = t && t.classes ? t.classes : "",
        r = [...n.split(" "), ...o.split(" ")],
        i = new Set(r);
      return Array.from(i).join(" ").trim();
    }
    _setOptions(e = {}) {
      let t = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
      t = b({}, t || {}), this.options = Object.assign({
        arrow: !0
      }, t, e, function (e, t) {
        return {
          floatingUIOptions: b(e.floatingUIOptions || {}, t.floatingUIOptions || {})
        };
      }(t, e));
      const {
        when: n
      } = this.options;
      this.options.classes = this._getClassOptions(e), this.destroy(), this.id = this.options.id || `step-${E()}`, n && Object.keys(n).forEach(e => {
        this.on(e, n[e], this);
      });
    }
    _setupElements() {
      o(this.el) || this.destroy(), this.el = this._createTooltipContent(), this.options.advanceOn && x(this), Be(this);
    }
    _show() {
      var e;
      this.trigger("before-show"), this._resolveAttachToOptions(), this._setupElements(), this.tour.modal || this.tour.setupModal(), null == (e = this.tour.modal) || e.setupForStep(this), this._styleTargetElementForStep(this), this.el && (this.el.hidden = !1), this.options.scrollTo && setTimeout(() => {
        this._scrollTo(this.options.scrollTo);
      }), this.el && (this.el.hidden = !1);
      const t = this.shepherdElementComponent.getElement(),
        n = this.target || document.body;
      n.classList.add(`${this.classPrefix}shepherd-enabled`), n.classList.add(`${this.classPrefix}shepherd-target`), t.classList.add("shepherd-enabled"), this.trigger("show");
    }
    _styleTargetElementForStep(e) {
      const t = e.target;
      t && (e.options.highlightClass && t.classList.add(e.options.highlightClass), t.classList.remove("shepherd-target-click-disabled"), !1 === e.options.canClickTarget && t.classList.add("shepherd-target-click-disabled"));
    }
    _updateStepTargetOnHide() {
      const e = this.target || document.body;
      this.options.highlightClass && e.classList.remove(this.options.highlightClass), e.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`);
    }
  }
  function dn(e, t) {
    return e.indexOf(t) >= 0;
  }
  function un(e, t, n) {
    return t = t || "", n || dn(e, " OPR/") ? dn(e, "Mini") ? "Opera Mini" : "Opera" : /(BlackBerry|PlayBook|BB10)/i.test(e) ? "BlackBerry" : dn(e, "IEMobile") || dn(e, "WPDesktop") ? "Internet Explorer Mobile" : dn(e, "SamsungBrowser/") ? "Samsung Internet" : dn(e, "Edge") || dn(e, "Edg/") ? "Microsoft Edge" : dn(e, "FBIOS") ? "Facebook Mobile" : dn(e, "Chrome") ? "Chrome" : dn(e, "CriOS") ? "Chrome iOS" : dn(e, "UCWEB") || dn(e, "UCBrowser") ? "UC Browser" : dn(e, "FxiOS") ? "Firefox iOS" : dn(t, "Apple") ? dn(e, "Mobile") ? "Mobile Safari" : "Safari" : dn(e, "Android") ? "Android Mobile" : dn(e, "Konqueror") ? "Konqueror" : dn(e, "Firefox") ? "Firefox" : dn(e, "MSIE") || dn(e, "Trident/") ? "Internet Explorer" : dn(e, "Gecko") ? "Mozilla" : "";
  }
  function hn(e, t, n) {
    const o = {
      "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
      "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
      Chrome: /Chrome\/(\d+(\.\d+)?)/,
      "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
      "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
      Safari: /Version\/(\d+(\.\d+)?)/,
      "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
      Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
      Firefox: /Firefox\/(\d+(\.\d+)?)/,
      "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
      Konqueror: /Konqueror:(\d+(\.\d+)?)/,
      BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
      "Android Mobile": /android\s(\d+(\.\d+)?)/,
      "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
      "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
      Mozilla: /rv:(\d+(\.\d+)?)/
    }[un(e, t, n)] || void 0;
    if (void 0 === o) return null;
    const r = e.match(o);
    return r ? parseFloat(r[r.length - 2]) : null;
  }
  function pn(e) {
    const t = e.navigator.userAgent;
    return /Windows/i.test(t) ? /Phone/.test(t) || /WPDesktop/.test(t) ? "Windows Phone" : "Windows" : /(iPhone|iPad|iPod)/.test(t) ? "iOS" : /Android/.test(t) ? "Android" : /(BlackBerry|PlayBook|BB10)/i.test(t) ? "BlackBerry" : /Mac/i.test(t) ? "Mac OS X" : /Linux/.test(t) ? "Linux" : /CrOS/.test(t) ? "Chrome OS" : "";
  }
  function fn(e) {
    return /Windows Phone/i.test(e) || /WPDesktop/.test(e) ? "Windows Phone" : /iPad/.test(e) ? "iPad" : /iPod/.test(e) ? "iPod Touch" : /iPhone/.test(e) ? "iPhone" : /(BlackBerry|PlayBook|BB10)/i.test(e) ? "BlackBerry" : /Android/.test(e) ? "Android" : "";
  }
  function gn(e) {
    const t = e.split("/");
    return t.length >= 3 ? t[2] : "";
  }
  const mn = (e, t) => t.some(t => e instanceof t);
  let bn, yn;
  const wn = new WeakMap(),
    vn = new WeakMap(),
    xn = new WeakMap();
  let $n = {
    get(e, t, n) {
      if (e instanceof IDBTransaction) {
        if ("done" === t) return wn.get(e);
        if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
      }
      return _n(e[t]);
    },
    set: (e, t, n) => (e[t] = n, !0),
    has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e
  };
  function Sn(e) {
    $n = e($n);
  }
  function kn(e) {
    return (yn || (yn = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function (...t) {
      return e.apply(On(this), t), _n(this.request);
    } : function (...t) {
      return _n(e.apply(On(this), t));
    };
  }
  function En(e) {
    return "function" == typeof e ? kn(e) : (e instanceof IDBTransaction && function (e) {
      if (wn.has(e)) return;
      const t = new Promise((t, n) => {
        const o = () => {
            e.removeEventListener("complete", r), e.removeEventListener("error", i), e.removeEventListener("abort", i);
          },
          r = () => {
            t(), o();
          },
          i = () => {
            n(e.error || new DOMException("AbortError", "AbortError")), o();
          };
        e.addEventListener("complete", r), e.addEventListener("error", i), e.addEventListener("abort", i);
      });
      wn.set(e, t);
    }(e), mn(e, bn || (bn = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])) ? new Proxy(e, $n) : e);
  }
  function _n(e) {
    if (e instanceof IDBRequest) return function (e) {
      const t = new Promise((t, n) => {
        const o = () => {
            e.removeEventListener("success", r), e.removeEventListener("error", i);
          },
          r = () => {
            t(_n(e.result)), o();
          },
          i = () => {
            n(e.error), o();
          };
        e.addEventListener("success", r), e.addEventListener("error", i);
      });
      return xn.set(t, e), t;
    }(e);
    if (vn.has(e)) return vn.get(e);
    const t = En(e);
    return t !== e && (vn.set(e, t), xn.set(t, e)), t;
  }
  const On = e => xn.get(e);
  const Tn = ["get", "getKey", "getAll", "getAllKeys", "count"],
    Ln = ["put", "add", "delete", "clear"],
    In = new Map();
  function Pn(e, t) {
    if (!(e instanceof IDBDatabase) || t in e || "string" != typeof t) return;
    if (In.get(t)) return In.get(t);
    const n = t.replace(/FromIndex$/, ""),
      o = t !== n,
      r = Ln.includes(n);
    if (!(n in (o ? IDBIndex : IDBObjectStore).prototype) || !r && !Tn.includes(n)) return;
    const i = async function (e, ...t) {
      const i = this.transaction(e, r ? "readwrite" : "readonly");
      let s = i.store;
      return o && (s = s.index(t.shift())), (await Promise.all([s[n](...t), r && i.done]))[0];
    };
    return In.set(t, i), i;
  }
  Sn(e => c({}, e, {
    get: (t, n, o) => Pn(t, n) || e.get(t, n, o),
    has: (t, n) => !!Pn(t, n) || e.has(t, n)
  }));
  const Cn = ["continue", "continuePrimaryKey", "advance"],
    An = {},
    Bn = new WeakMap(),
    Mn = new WeakMap(),
    Dn = {
      get(e, t) {
        if (!Cn.includes(t)) return e[t];
        let n = An[t];
        return n || (n = An[t] = function (...e) {
          Bn.set(this, Mn.get(this)[t](...e));
        }), n;
      }
    };
  function Fn() {
    return Rn.apply(this, arguments);
  }
  function Rn() {
    var e;
    return e = function* (...e) {
      let t = this;
      if (t instanceof IDBCursor || (t = yield a(t.openCursor(...e))), !t) return;
      const n = new Proxy(t, Dn);
      for (Mn.set(n, t), xn.set(n, On(t)); t;) yield n, t = yield a(Bn.get(n) || t.continue()), Bn.delete(n);
    }, Rn = function () {
      return new i(e.apply(this, arguments));
    }, Rn.apply(this, arguments);
  }
  function jn(e, t) {
    return t === Symbol.asyncIterator && mn(e, [IDBIndex, IDBObjectStore, IDBCursor]) || "iterate" === t && mn(e, [IDBIndex, IDBObjectStore]);
  }
  Sn(e => c({}, e, {
    get: (t, n, o) => jn(t, n) ? Fn : e.get(t, n, o),
    has: (t, n) => jn(t, n) || e.has(t, n)
  }));
  class Hn {
    constructor(e, t, n) {
      if (this.apiKey = void 0, this.apiPath = void 0, this.properties = void 0, this.tourStateDb = void 0, !e) throw new Error("Shepherd Pro: Missing required apiKey option.");
      if (!t) throw new Error("Shepherd Pro: Missing required apiPath option.");
      this.apiKey = e, this.apiPath = t, this.properties = n;
    }
    async getTourState() {
      try {
        const e = await fetch(`${this.apiPath}/api/v1/state`, {
          headers: {
            Authorization: `ApiKey ${this.apiKey}`,
            "Content-Type": "application/json"
          },
          method: "GET"
        });
        if (!e.ok) throw new Error("Could not fetch state for tours ðŸ‘");
        const {
          data: t
        } = await e.json();
        if (this.tourStateDb = await function (e, t, {
          blocked: n,
          upgrade: o,
          blocking: r,
          terminated: i
        } = {}) {
          const s = indexedDB.open(e, t),
            a = _n(s);
          return o && s.addEventListener("upgradeneeded", e => {
            o(_n(s.result), e.oldVersion, e.newVersion, _n(s.transaction), e);
          }), n && s.addEventListener("blocked", e => n(e.oldVersion, e.newVersion, e)), a.then(e => {
            i && e.addEventListener("close", () => i()), r && e.addEventListener("versionchange", e => r(e.oldVersion, e.newVersion, e));
          }).catch(() => {}), a;
        }("TourState", 1, {
          upgrade(e) {
            e.createObjectStore("tours", {
              keyPath: "uniqueId"
            });
          }
        }), Array.isArray(t) && t.length) {
          const e = this.tourStateDb.transaction("tours", "readwrite"),
            n = t.map(t => e.store.put(t));
          await Promise.all([...n, e.done]);
        }
      } catch (e) {
        throw new Error("Error fetching data: " + (e instanceof Error ? e.message : "Unknown error"));
      }
    }
    async sendEvents(e) {
      e.data.properties = this.properties;
      try {
        const t = await fetch(`${this.apiPath}/api/v1/actor`, {
          headers: {
            Authorization: `ApiKey ${this.apiKey}`,
            "Content-Type": "application/json"
          },
          method: "POST",
          body: JSON.stringify(e)
        });
        if (!t.ok) throw new Error("Could not create an event ðŸ‘");
        const {
          data: n
        } = await t.json();
        return n;
      } catch (e) {
        throw new Error("Error fetching data: " + (e instanceof Error ? e.message : "Unknown error"));
      }
    }
  }
  function qn(e) {
    let t, n, o, r, i;
    return {
      c() {
        t = Ke("svg"), n = Ke("path"), Ge(n, "d", e[2]), Ge(t, "class", o = (e[1] ? "shepherd-modal-is-visible" : "") + " shepherd-modal-overlay-container");
      },
      m(o, s) {
        We(o, t, s), Ne(t, n), e[11](t), r || (i = Ye(t, "touchmove", e[3]), r = !0);
      },
      p(e, [r]) {
        4 & r && Ge(n, "d", e[2]), 2 & r && o !== (o = (e[1] ? "shepherd-modal-is-visible" : "") + " shepherd-modal-overlay-container") && Ge(t, "class", o);
      },
      i: Me,
      o: Me,
      d(n) {
        n && Ve(t), e[11](null), r = !1, i();
      }
    };
  }
  function Nn(e) {
    if (!e) return null;
    const t = e instanceof HTMLElement && window.getComputedStyle(e).overflowY;
    return "hidden" !== t && "visible" !== t && e.scrollHeight >= e.clientHeight ? e : Nn(e.parentElement);
  }
  function Wn(e, t, n) {
    let o,
      r,
      {
        element: i,
        openingProperties: s
      } = t,
      a = !1;
    c();
    function c() {
      n(4, s = {
        width: 0,
        height: 0,
        x: 0,
        y: 0,
        r: 0
      });
    }
    function l() {
      n(1, a = !1), p();
    }
    function d(e = 0, t = 0, o = 0, r = 0, i, a) {
      if (a) {
        const {
            y: c,
            height: l
          } = function (e, t) {
            const n = e.getBoundingClientRect();
            let o = n.y || n.top,
              r = n.bottom || o + n.height;
            if (t) {
              const e = t.getBoundingClientRect(),
                n = e.y || e.top,
                i = e.bottom || n + e.height;
              o = Math.max(o, n), r = Math.min(r, i);
            }
            return {
              y: o,
              height: Math.max(r - o, 0)
            };
          }(a, i),
          {
            x: d,
            width: u,
            left: h
          } = a.getBoundingClientRect();
        n(4, s = {
          width: u + 2 * e,
          height: l + 2 * e,
          x: (d || h) + o - e,
          y: c + r - e,
          r: t
        });
      } else c();
    }
    function u() {
      n(1, a = !0);
    }
    const h = e => {
      e.preventDefault();
    };
    function p() {
      o && (cancelAnimationFrame(o), o = void 0), window.removeEventListener("touchmove", h, {
        passive: !1
      });
    }
    return e.$$set = e => {
      "element" in e && n(0, i = e.element), "openingProperties" in e && n(4, s = e.openingProperties);
    }, e.$$.update = () => {
      16 & e.$$.dirty && n(2, r = function ({
        width: e,
        height: t,
        x: n = 0,
        y: o = 0,
        r = 0
      }) {
        const {
            innerWidth: i,
            innerHeight: s
          } = window,
          {
            topLeft: a = 0,
            topRight: c = 0,
            bottomRight: l = 0,
            bottomLeft: d = 0
          } = "number" == typeof r ? {
            topLeft: r,
            topRight: r,
            bottomRight: r,
            bottomLeft: r
          } : r;
        return `M${i},${s}H0V0H${i}V${s}ZM${n + a},${o}a${a},${a},0,0,0-${a},${a}V${t + o - d}a${d},${d},0,0,0,${d},${d}H${e + n - l}a${l},${l},0,0,0,${l}-${l}V${o + c}a${c},${c},0,0,0-${c}-${c}Z`;
      }(s));
    }, [i, a, r, e => {
      e.stopPropagation();
    }, s, () => i, c, l, d, function (e) {
      p(), e.tour.options.useModalOverlay ? (!function (e) {
        const {
            modalOverlayOpeningPadding: t,
            modalOverlayOpeningRadius: n,
            modalOverlayOpeningXOffset: r = 0,
            modalOverlayOpeningYOffset: i = 0
          } = e.options,
          s = function (e) {
            let t = {
              top: 0,
              left: 0
            };
            if (!e) return t;
            let n = e.ownerDocument.defaultView;
            for (; n !== window.top;) {
              var o;
              const e = null == (o = n) ? void 0 : o.frameElement;
              if (e) {
                var r, i;
                const n = e.getBoundingClientRect();
                t.top += n.top + (null != (r = n.scrollTop) ? r : 0), t.left += n.left + (null != (i = n.scrollLeft) ? i : 0);
              }
              n = n.parent;
            }
            return t;
          }(e.target),
          a = Nn(e.target),
          c = () => {
            o = void 0, d(t, n, r + s.left, i + s.top, a, e.target), o = requestAnimationFrame(c);
          };
        c(), window.addEventListener("touchmove", h, {
          passive: !1
        });
      }(e), u()) : l();
    }, u, function (e) {
      it[e ? "unshift" : "push"](() => {
        i = e, n(0, i);
      });
    }];
  }
  class Vn extends Ot {
    constructor(e) {
      super(), _t(this, e, Wn, qn, qe, {
        element: 0,
        openingProperties: 4,
        getElement: 5,
        closeModalOpening: 6,
        hide: 7,
        positionModal: 8,
        setupForStep: 9,
        show: 10
      });
    }
    get getElement() {
      return this.$$.ctx[5];
    }
    get closeModalOpening() {
      return this.$$.ctx[6];
    }
    get hide() {
      return this.$$.ctx[7];
    }
    get positionModal() {
      return this.$$.ctx[8];
    }
    get setupForStep() {
      return this.$$.ctx[9];
    }
    get show() {
      return this.$$.ctx[10];
    }
  }
  const zn = "shepherdPro:userId";
  const Kn = new class extends r {
      constructor(...e) {
        super(...e), this.apiKey = void 0, this.apiPath = void 0, this.dataRequester = void 0, this.isProEnabled = !1, this.properties = void 0, this.activeTour = void 0;
      }
      async init(e, t, n) {
        if (!e) throw new Error("Shepherd Pro: Missing required apiKey option.");
        if (this.apiKey = e, this.apiPath = null != t ? t : "https://shepherdpro.com", this.properties = null != n ? n : {}, this.properties.context = function (e) {
          let t = {};
          if (e.navigator) {
            const n = e.navigator.userAgent;
            t = c({}, t, {
              $os: pn(e),
              $browser: un(n, e.navigator.vendor, !!e.opera),
              $referrer: e.document.referrer,
              $referring_domain: gn(e.document.referrer),
              $device: fn(n),
              $current_url: e.location.href,
              $host: e.location.host,
              $pathname: e.location.pathname,
              $browser_version: hn(n, e.navigator.vendor, !!e.opera),
              $screen_height: e.screen.height,
              $screen_width: e.screen.width,
              $screen_dpr: e.devicePixelRatio
            });
          }
          return t = c({}, t, {
            $lib: "js",
            $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10),
            $time: new Date().getTime() / 1e3
          }), t;
        }(window), this.apiKey) {
          this.dataRequester = new Hn(this.apiKey, this.apiPath, this.properties), this.isProEnabled = !0;
          const e = localStorage.getItem(zn),
            t = [this.dataRequester.getTourState()];
          e || t.push(this.createNewActor()), await Promise.all(t);
        }
      }
      async createNewActor() {
        if (!this.dataRequester) return;
        const e = await this.dataRequester.sendEvents({
          data: {
            currentUserId: null,
            eventType: "setup"
          }
        });
        localStorage.setItem(zn, String(e.actorId));
      }
      async isTourEnabled(e) {
        var t, n;
        if (!this.dataRequester) return;
        const o = await (null == (t = this.dataRequester.tourStateDb) ? void 0 : t.get("tours", e));
        return null == (n = null == o ? void 0 : o.isActive) || n;
      }
    }(),
    Un = "undefined" == typeof window;
  Kn.Step = Un ? class {
    constructor(e) {}
  } : ln, Kn.Tour = Un ? class {
    constructor(e, t) {}
  } : class extends r {
    constructor(e = {}) {
      super(), this.trackedEvents = ["active", "cancel", "complete", "show"], this.classPrefix = void 0, this.currentStep = void 0, this.focusedElBeforeOpen = void 0, this.id = void 0, this.modal = void 0, this.options = void 0, this.steps = void 0, v(this);
      this.options = Object.assign({}, {
        exitOnEsc: !0,
        keyboardNavigation: !0
      }, e), this.classPrefix = S(this.options.classPrefix), this.steps = [], this.addSteps(this.options.steps);
      ["active", "cancel", "complete", "inactive", "show", "start"].map(e => {
        (e => {
          this.on(e, t => {
            (t = t || {}).tour = this, Kn.trigger(e, t);
          });
        })(e);
      }), this._setTourID(e.id);
      const {
        dataRequester: t
      } = Kn;
      return t && this.trackedEvents.forEach(e => this.on(e, n => {
        const {
            tour: o
          } = n,
          {
            id: r,
            steps: i
          } = o;
        let s;
        if ("active" !== e) {
          const {
            step: e
          } = n;
          e && (s = i.findIndex(t => t.id === e.id) + 1);
        }
        const a = {
          currentUserId: localStorage.getItem(zn),
          eventType: e,
          journeyData: {
            id: r,
            currentStep: s,
            numberOfSteps: i.length,
            tourOptions: o.options
          }
        };
        t.sendEvents({
          data: a
        });
      })), this;
    }
    addStep(e, t) {
      let n = e;
      return n instanceof ln ? n.tour = this : n = new ln(this, n), o(t) ? this.steps.push(n) : this.steps.splice(t, 0, n), n;
    }
    addSteps(e) {
      return Array.isArray(e) && e.forEach(e => {
        this.addStep(e);
      }), this;
    }
    back() {
      const e = this.steps.indexOf(this.currentStep);
      this.show(e - 1, !1);
    }
    async cancel() {
      if (this.options.confirmCancel) {
        const e = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
        let n;
        n = t(this.options.confirmCancel) ? await this.options.confirmCancel() : window.confirm(e), n && this._done("cancel");
      } else this._done("cancel");
    }
    complete() {
      this._done("complete");
    }
    getById(e) {
      return this.steps.find(t => t.id === e);
    }
    getCurrentStep() {
      return this.currentStep;
    }
    hide() {
      const e = this.getCurrentStep();
      if (e) return e.hide();
    }
    isActive() {
      return Kn.activeTour === this;
    }
    next() {
      const e = this.steps.indexOf(this.currentStep);
      e === this.steps.length - 1 ? this.complete() : this.show(e + 1, !0);
    }
    removeStep(e) {
      const t = this.getCurrentStep();
      this.steps.some((t, n) => {
        if (t.id === e) return t.isOpen() && t.hide(), t.destroy(), this.steps.splice(n, 1), !0;
      }), t && t.id === e && (this.currentStep = void 0, this.steps.length ? this.show(0) : this.cancel());
    }
    show(e = 0, o = !0) {
      const r = n(e) ? this.getById(e) : this.steps[e];
      if (r) {
        this._updateStateBeforeShow();
        t(r.options.showOn) && !r.options.showOn() ? this._skipStep(r, o) : (this.trigger("show", {
          step: r,
          previous: this.currentStep
        }), this.currentStep = r, r.show());
      }
    }
    async start() {
      Kn.isProEnabled && !(await Kn.isTourEnabled(this.options.id)) || (this.trigger("start"), this.focusedElBeforeOpen = document.activeElement, this.currentStep = null, this.setupModal(), this._setupActiveTour(), this.next());
    }
    _done(t) {
      const n = this.steps.indexOf(this.currentStep);
      if (Array.isArray(this.steps) && this.steps.forEach(e => e.destroy()), function (t) {
        if (t) {
          const {
            steps: n
          } = t;
          n.forEach(t => {
            t.options && !1 === t.options.canClickTarget && t.options.attachTo && e(t.target) && t.target.classList.remove("shepherd-target-click-disabled");
          });
        }
      }(this), this.trigger(t, {
        index: n
      }), Kn.activeTour = null, this.trigger("inactive", {
        tour: this
      }), this.modal && this.modal.hide(), ("cancel" === t || "complete" === t) && this.modal) {
        const e = document.querySelector(".shepherd-modal-overlay-container");
        e && (e.remove(), this.modal = null);
      }
      e(this.focusedElBeforeOpen) && this.focusedElBeforeOpen.focus();
    }
    _setupActiveTour() {
      this.trigger("active", {
        tour: this
      }), Kn.activeTour = this;
    }
    setupModal() {
      this.modal = new Vn({
        target: this.options.modalContainer || document.body,
        props: {
          styles: this.styles
        }
      });
    }
    _skipStep(e, t) {
      const n = this.steps.indexOf(e);
      if (n === this.steps.length - 1) this.complete();else {
        const e = t ? n + 1 : n - 1;
        this.show(e, t);
      }
    }
    _updateStateBeforeShow() {
      this.currentStep && this.currentStep.hide(), this.isActive() || this._setupActiveTour();
    }
    _setTourID(e) {
      const t = this.options.tourName || "tour",
        n = e || E();
      this.id = `${t}--${n}`;
    }
  };
  !function (e, t) {
    void 0 === t && (t = {});
    var n = t.insertAt;
    if ("undefined" != typeof document) {
      var o = document.head || document.getElementsByTagName("head")[0],
        r = document.createElement("style");
      r.type = "text/css", "top" === n && o.firstChild ? o.insertBefore(r, o.firstChild) : o.appendChild(r), r.styleSheet ? r.styleSheet.cssText = e : r.appendChild(document.createTextNode(e));
    }
  }('.shepherd-button{background:#3288e6;border:0;border-radius:3px;color:hsla(0,0%,100%,.75);cursor:pointer;margin-right:.5rem;padding:.5rem 1.5rem;transition:all .5s ease}.shepherd-button:not(:disabled):hover{background:#196fcc;color:hsla(0,0%,100%,.75)}.shepherd-button.shepherd-button-secondary{background:#f1f2f3;color:rgba(0,0,0,.75)}.shepherd-button.shepherd-button-secondary:not(:disabled):hover{background:#d6d9db;color:rgba(0,0,0,.75)}.shepherd-button:disabled{cursor:not-allowed}.shepherd-footer{border-bottom-left-radius:5px;border-bottom-right-radius:5px;display:flex;justify-content:flex-end;padding:0 .75rem .75rem}.shepherd-footer .shepherd-button:last-child{margin-right:0}.shepherd-cancel-icon{background:transparent;border:none;color:hsla(0,0%,50%,.75);cursor:pointer;font-size:2em;font-weight:400;margin:0;padding:0;transition:color .5s ease}.shepherd-cancel-icon:hover{color:rgba(0,0,0,.75)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon{color:hsla(0,0%,50%,.75)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover{color:rgba(0,0,0,.75)}.shepherd-title{color:rgba(0,0,0,.75);display:flex;flex:1 0 auto;font-size:1rem;font-weight:400;margin:0;padding:0}.shepherd-header{align-items:center;border-top-left-radius:5px;border-top-right-radius:5px;display:flex;justify-content:flex-end;line-height:2em;padding:.75rem .75rem 0}.shepherd-has-title .shepherd-content .shepherd-header{background:#e6e6e6;padding:1em}.shepherd-text{color:rgba(0,0,0,.75);font-size:1rem;line-height:1.3em;padding:.75em}.shepherd-text p{margin-top:0}.shepherd-text p:last-child{margin-bottom:0}.shepherd-content{border-radius:5px;outline:none;padding:0}.shepherd-element{background:#fff;border-radius:5px;box-shadow:0 1px 4px rgba(0,0,0,.2);max-width:400px;opacity:0;outline:none;transition:opacity .3s,visibility .3s;visibility:hidden;width:100%;z-index:9999}.shepherd-enabled.shepherd-element{opacity:1;visibility:visible}.shepherd-element[data-popper-reference-hidden]:not(.shepherd-centered){opacity:0;pointer-events:none;visibility:hidden}.shepherd-element,.shepherd-element *,.shepherd-element :after,.shepherd-element :before{box-sizing:border-box}.shepherd-arrow,.shepherd-arrow:before{height:16px;position:absolute;width:16px;z-index:-1}.shepherd-arrow:before{background:#fff;content:"";transform:rotate(45deg)}.shepherd-element[data-popper-placement^=top]>.shepherd-arrow{bottom:-8px}.shepherd-element[data-popper-placement^=bottom]>.shepherd-arrow{top:-8px}.shepherd-element[data-popper-placement^=left]>.shepherd-arrow{right:-8px}.shepherd-element[data-popper-placement^=right]>.shepherd-arrow{left:-8px}.shepherd-element.shepherd-centered>.shepherd-arrow{opacity:0}.shepherd-element.shepherd-has-title[data-popper-placement^=bottom]>.shepherd-arrow:before{background-color:#e6e6e6}.shepherd-target-click-disabled.shepherd-enabled.shepherd-target,.shepherd-target-click-disabled.shepherd-enabled.shepherd-target *{pointer-events:none}.shepherd-modal-overlay-container{height:0;left:0;opacity:0;overflow:hidden;pointer-events:none;position:fixed;top:0;transition:all .3s ease-out,height 0ms .3s,opacity .3s 0ms;width:100vw;z-index:9997}.shepherd-modal-overlay-container.shepherd-modal-is-visible{height:100vh;opacity:.5;transform:translateZ(0);transition:all .3s ease-out,height 0s 0s,opacity .3s 0s}.shepherd-modal-overlay-container.shepherd-modal-is-visible path{pointer-events:all}.shepherd-element{border-width:1px;border-color:var(--color-background-tertiary);background-color:var(--color-background-primary);color:var(--color-text-primary);--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shepherd-element:is(.sp-theme-dark *){background-color:var(--color-background-secondary)}.shepherd-element {\r\n    z-index: 10005;\r\n}.shepherd-arrow:before{background-color:var(--color-background-primary)}.shepherd-arrow:is(.sp-theme-dark *):before{background-color:var(--color-background-secondary)}.shepherd-element.shepherd-has-title[data-popper-placement^=bottom]>.shepherd-arrow:before{background-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=top]>.shepherd-arrow:before,\r\n.shepherd-element.shepherd-has-title[data-popper-placement^=right]>.shepherd-arrow:before{border-bottom-width:1px;border-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=top]>.shepherd-arrow:before,\r\n.shepherd-element.shepherd-has-title[data-popper-placement^=left]>.shepherd-arrow:before{border-right-width:1px;border-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=right]>.shepherd-arrow:before{border-left-width:1px;border-color:var(--color-background-tertiary)}.shepherd-element.shepherd-has-title[data-popper-placement^=left]>.shepherd-arrow:before{border-top-width:1px;border-color:var(--color-background-tertiary)}.shepherd-has-title .shepherd-content .shepherd-header{background-color:var(--color-background-tertiary);padding-left:1rem;padding-right:1rem;padding-top:0.5rem;padding-bottom:0.5rem}.shepherd-title{font-size:1.125rem;font-weight:700;color:var(--color-text-primary)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon{color:var(--color-text-secondary);--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover{color:var(--color-text-primary)}.shepherd-cancel-icon{font-size:1.5rem;font-weight:700}.shepherd-text{overflow:auto;color:var(--color-text-primary)}.shepherd-button{border-radius:0.25rem;background-color:var(--color-primary-800);color:var(--color-white, #fff)}.shepherd-button:not(:disabled):hover{background-color:var(--color-primary-900);color:var(--color-white, #fff)}\r\n'), App.extend("tour", new function () {
    var e = this,
      t = null,
      n = "supportpalProductTour",
      o = {
        defaultStepOptions: {
          scrollTo: {
            behavior: "smooth"
          },
          buttons: [{
            text: Lang.get("general.next"),
            action: function () {
              return this.next();
            }
          }],
          cancelIcon: {
            enabled: !0
          }
        }
      },
      r = [{
        id: "step-1",
        title: Lang.get("core.dashboard"),
        text: Lang.get("core.dashboard_desc")
      }, {
        id: "step-2",
        title: Lang.get("core.private_messages"),
        text: Lang.get("core.messages_desc"),
        attachTo: {
          element: "#privateMessages",
          on: "bottom"
        }
      }, {
        id: "step-3",
        title: Lang.get("core.configure"),
        text: Lang.get("core.configure_desc"),
        attachTo: {
          element: "#settingsNavigation",
          on: "bottom"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.setting");
          }
        }]
      }, {
        id: "step-4",
        title: Lang.choice("core.brand", 2),
        text: Lang.get("core.brand_desc"),
        attachTo: {
          element: "#brandSettings",
          on: "right"
        },
        when: {
          show: function () {
            Cookies.remove("generalSettingsBox"), $("#generalSettingsBox").hasClass("sp-closed") && $("#generalSettingsBox").trigger("click");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.brand.edit", {
              brand: 1
            });
          }
        }]
      }, {
        id: "step-5",
        title: Lang.get("core.brand_name"),
        text: Lang.get("core.brand_name_desc"),
        attachTo: {
          element: "#name",
          on: "bottom"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            return $("#Email").trigger("click"), this.next();
          }
        }]
      }, {
        id: "step-6",
        title: Lang.get("core.default_email"),
        text: Lang.get("core.default_email_desc"),
        attachTo: {
          element: "#default_email",
          on: "bottom"
        },
        when: {
          show: function () {
            Cookies.remove("ticketSettingsBox"), $("#generalSettingsBox").hasClass("sp-closed") || $("#generalSettingsBox").trigger("click"), $("#ticketSettingsBox").hasClass("sp-closed") && $("#ticketSettingsBox").trigger("click");
          }
        }
      }, {
        id: "step-7",
        title: Lang.choice("ticket.department", 2),
        text: Lang.get("core.department_desc"),
        attachTo: {
          element: "#ticketDeptSetting",
          on: "right"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.operator.department.edit", {
              department: 0
            });
          }
        }]
      }, {
        id: "step-8",
        title: Lang.choice("ticket.department", 2),
        text: Lang.get("core.dept_settings_desc"),
        attachTo: {
          element: "#departmentSettings",
          on: "top"
        }
      }, {
        id: "step-9",
        title: Lang.get("core.department_email"),
        text: Lang.get("core.dept_email_desc"),
        attachTo: {
          element: "#emailAccounts",
          on: "top"
        }
      }, {
        id: "step-10",
        title: Lang.get("core.dept_tmpl"),
        text: Lang.get("core.dept_tmpl_desc"),
        attachTo: {
          element: "#department-templates",
          on: "bottom"
        }
      }, {
        id: "step-11",
        title: Lang.choice("core.scheduled_task", 2),
        text: Lang.get("core.schedule_task_desc"),
        attachTo: {
          element: "#scheduledTaskSetting",
          on: "right"
        },
        when: {
          show: function () {
            $("#generalSettingsBox").hasClass("sp-closed") && $("#generalSettingsBox").trigger("click"), $("#ticketSettingsBox").hasClass("sp-closed") || $("#ticketSettingsBox").trigger("click");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.scheduledtask.index");
          }
        }]
      }, {
        id: "step-12",
        title: Lang.choice("core.scheduled_task", 2),
        text: Lang.get("core.schedule_task_2"),
        attachTo: {
          element: "#scheduledTaskTable",
          on: "top"
        }
      }, {
        id: "step-13",
        title: Lang.get("core.schedule_task_cron"),
        text: Lang.get("core.schedule_task_3"),
        attachTo: {
          element: "#scheduledTaskCron",
          on: "top"
        }
      }, {
        id: "step-14",
        title: Lang.choice("ticket.channel", 2),
        text: Lang.get("core.ticket_channel_desc"),
        attachTo: {
          element: "#channelSettings",
          on: "right"
        },
        when: {
          show: function () {
            $("#generalSettingsBox").hasClass("sp-closed") || $("#generalSettingsBox").trigger("click"), $("#ticketSettingsBox").hasClass("sp-closed") && $("#ticketSettingsBox").trigger("click");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.operator.channel.index");
          }
        }]
      }, {
        id: "step-15",
        title: Lang.choice("ticket.channel", 2),
        text: Lang.get("core.ticket_channel_2"),
        attachTo: {
          element: "#ticketChannelTable",
          on: "top"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.channel.web.settings");
          }
        }]
      }, {
        id: "step-16",
        title: Lang.get("ticket.web_settings"),
        text: Lang.get("core.web_settings_desc"),
        attachTo: {
          element: "#unauthenticated_users_label",
          on: "bottom"
        }
      }, {
        id: "step-17",
        title: Lang.choice("user.user", 2),
        text: Lang.get("core.user_desc"),
        attachTo: {
          element: "#manageUserSetting",
          on: "right"
        },
        when: {
          show: function () {
            $("#userHeaderDropdown > a").addClass("sp-hover");
          }
        }
      }, {
        id: "step-18",
        title: Lang.choice("user.organisation", 2),
        text: Lang.get("core.organisation_desc"),
        attachTo: {
          element: "#manageOrgSetting",
          on: "right"
        }
      }, {
        id: "step-19",
        title: Lang.choice("general.operator", 2),
        text: Lang.get("core.operator_desc"),
        attachTo: {
          element: "#manageOperatorSetting",
          on: "right"
        }
      }, {
        id: "step-20",
        title: Lang.choice("ticket.ticket", 2),
        text: Lang.get("core.ticket_desc"),
        attachTo: {
          element: "#manageTickets",
          on: "right"
        },
        when: {
          show: function () {
            $("#ticketHeaderDropdown > a").addClass("sp-hover"), $("#userHeaderDropdown > a").removeClass("sp-hover");
          }
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("ticket.operator.ticket");
          }
        }]
      }, {
        id: "step-21",
        title: Lang.choice("ticket.ticket", 2),
        text: Lang.get("core.ticket_desc2"),
        attachTo: {
          element: "#ticketGridTable",
          on: "top"
        },
        when: {
          show: function () {
            $("#ticketHeaderDropdown > a").removeClass("sp-hover");
          }
        }
      }, {
        id: "step-22",
        title: Lang.get("core.ticket_toolbar"),
        text: Lang.get("core.ticket_desc3"),
        attachTo: {
          element: "#openNewTicket",
          on: "bottom"
        },
        buttons: [{
          text: Lang.get("general.next"),
          action: function () {
            e.setStep(this.getCurrentStep().id), window.location = laroute.route("core.operator.dashboard");
          }
        }]
      }, {
        id: "step-23",
        title: Lang.get("core.tour_complete"),
        text: Lang.get("core.tour_complete_desc"),
        buttons: [{
          text: Lang.get("general.dismiss"),
          action: function () {
            return this.complete();
          }
        }]
      }],
      i = function () {
        e.clearStep(), $.post(laroute.route("core.operator.product_tour.toggle"));
      };
    this.getStep = function () {
      return localStorage.getItem(n);
    }, this.setStep = function (e) {
      localStorage.setItem(n, e);
    }, this.clearStep = function () {
      localStorage.removeItem(n);
    }, this.start = function () {
      return this.instance().start();
    }, this.show = function (e) {
      return this.instance().show("step-" + e);
    }, this.instance = function () {
      return null === t && ((t = new Kn.Tour(o)).addSteps(r), t.on("complete", i), t.on("cancel", i)), t;
    }, this.instance();
  }()), $(function () {
    if (null !== App.tour.getStep()) {
      var e = [location.protocol, "//", location.host, location.pathname].join(""),
        t = parseInt(App.tour.getStep().split("-")[1]) + 1;
      e == laroute.route("core.operator.dashboard") ? $("#widgets").on("widgetsLoaded", function (e) {
        App.tour.show(t);
      }) : App.tour.show(t);
    }
  });
});